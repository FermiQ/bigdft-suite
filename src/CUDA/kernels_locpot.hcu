#ifndef __kernels_locpot__
#define __kernels_locpot__

#include "structDef_locpot.h"

//1D convolution of multiple lines in the same block
//__global__ void magicfilter1d(int n,int ndat, float *psi_out) //for textures

template<typename T>
__global__ void magicfilter1d(int n,int ndat, T *psi_in, T *psi_out,int idim)
{

  //line treated by the given block
  unsigned int lineOffset = min(blockIdx.y*NUM_LINES,ndat-NUM_LINES);
  //starting element treated by the block
  unsigned int elemOffset = min(blockIdx.x*par[idim].ElementsPerBlock,n-par[idim].ElementsPerBlock);

  //half-warp id
  const unsigned int hwid = threadIdx.y;
  //tid within the HW
  const unsigned int tid_hw = threadIdx.x;

  //shared memory array
  __shared__ T psi_sh[MAX_SHARED_SIZE/sizeof(T)];

  //line treated by the given thread in ndat axis
  //which is the input base element
  unsigned int BaseElem = par[idim].thline[tid_hw] + lineOffset;
  //write data in shared memory
  //element treated by the given thread in n-axis
  unsigned int thelem = par[idim].thelem[tid_hw] + par[idim].hwoffset_copy[hwid];

  unsigned int ShBaseElem = tid_hw + NUM_LINES*par[idim].hwoffset_copy[hwid];

  int epsilon,npos;

  //NOTE: it is assumed that for non-first segments the starting
  //points is far enough for the filter to be contained
  //and the same for non-last segments.
  //in other terms: lenght of the line is always bigger than
  //max(lowfil,lupfil)

  for(int i=0,ipos=elemOffset-LOWFILMF+thelem;i < par[idim].hwelem_copy[hwid] ; ++i)
    {
      epsilon=(ipos < 0 ? -1 : ipos/n);
      npos=ipos-epsilon*n;
      psi_sh[ShBaseElem]=psi_in[BaseElem+ndat*npos];
      //psi_sh[ShBaseElem]=tex1Dfetch(psi_tex,BaseElem+ndat*npos);

      ShBaseElem += HALF_WARP_SIZE;
      ipos += HW_ELEM;
      
    }

  //end shared memory copy
  __syncthreads();

  //element treated by the given thread in n-axis
  thelem = par[idim].thelem[tid_hw] + par[idim].hwoffset_calc[hwid];
  //base element for the given thread in shared memory
  ShBaseElem = tid_hw + NUM_LINES*par[idim].hwoffset_calc[hwid];

  //output base element, from the input one
  BaseElem =  n*BaseElem+ thelem + elemOffset;

  //perform convolution in shared memory 
  //each thread calculate a number of elements, identical for each
  //half-warp
  //#pragma unroll 5 (to be tested if it is important)

  for(int i=0;i < par[idim].hwelem_calc[hwid]; ++i)
    {
      //values of the convolution
      register T conv = 
	//hand-unrolled loop (16 elements for this filter)
	//order changed for increasing the precision
	MFIL0 *psi_sh[ShBaseElem               ] +
	MFIL15*psi_sh[ShBaseElem + 15*NUM_LINES] +
	MFIL1 *psi_sh[ShBaseElem +   NUM_LINES ] +
	MFIL14*psi_sh[ShBaseElem + 14*NUM_LINES] +
	MFIL2 *psi_sh[ShBaseElem + 2*NUM_LINES ] +
	MFIL13*psi_sh[ShBaseElem + 13*NUM_LINES] +
	MFIL3 *psi_sh[ShBaseElem + 3*NUM_LINES ] +
	MFIL12*psi_sh[ShBaseElem + 12*NUM_LINES] +
	MFIL4 *psi_sh[ShBaseElem + 4*NUM_LINES ] +
	MFIL11*psi_sh[ShBaseElem + 11*NUM_LINES] +
	MFIL5 *psi_sh[ShBaseElem + 5*NUM_LINES ] +
	MFIL10*psi_sh[ShBaseElem + 10*NUM_LINES] +
	MFIL6 *psi_sh[ShBaseElem + 6*NUM_LINES ] +
	MFIL9 *psi_sh[ShBaseElem + 9*NUM_LINES ] +
	MFIL7 *psi_sh[ShBaseElem + 7*NUM_LINES ] +
	MFIL8 *psi_sh[ShBaseElem + 8*NUM_LINES ] ;

      psi_out[BaseElem]=conv;
      //psi_sh[ShBaseElem+LOWFILMF*par[idim].LinesPerBlock]; //for testing only

      ShBaseElem += HALF_WARP_SIZE;
      BaseElem += HW_ELEM;
      
    }

}

//1D convolution of multiple lines in the same block
//multiplies by the potential and calculate the potential energy
//__global__ void magicfilter1d_pot(int n,int ndat, float *psi_out)
template<typename T>
__global__ void magicfilter1d_pot(int n,int ndat, T *psi_in, 
				  T *pot, T *psi_out,int idim)
{

  //line treated by the given block
  unsigned int lineOffset = min(blockIdx.y*NUM_LINES,ndat-NUM_LINES);
  //starting element treated by the block
  unsigned int elemOffset = min(blockIdx.x*par[idim].ElementsPerBlock,n-par[idim].ElementsPerBlock);

  //half-warp id
  const unsigned int hwid = threadIdx.y;
  //tid within the HW
  const unsigned int tid_hw = threadIdx.x;

  //shared memory array
  __shared__ T psi_sh[MAX_SHARED_SIZE/sizeof(T)];

  //line treated by the given thread in ndat axis
  //which is the input base element
  unsigned int BaseElem = par[idim].thline[tid_hw] + lineOffset;
  //write data in shared memory
  //element treated by the given thread in n-axis
  unsigned int thelem = par[idim].thelem[tid_hw] + par[idim].hwoffset_copy[hwid];

  unsigned int ShBaseElem = tid_hw + NUM_LINES*par[idim].hwoffset_copy[hwid];

  int epsilon,npos;

  //NOTE: it is assumed that for non-first segments the starting
  //points is far enough for the filter to be contained
  //and the same for non-last segments.
  //in other terms: lenght of the line is always bigger than
  //max(lowfil,lupfil)

  for(int i=0,ipos=elemOffset-LOWFILMF+thelem;i < par[idim].hwelem_copy[hwid] ; ++i)
    {
      //control flag for periodic boundary conditions
      epsilon=(ipos < 0 ? -1 : ipos/n);
      npos=ipos-epsilon*n;

      psi_sh[ShBaseElem]=psi_in[BaseElem+ndat*npos];
      //psi_sh[ShBaseElem]=tex1Dfetch(psi_tex,BaseElem+ndat*npos);

      ShBaseElem += HALF_WARP_SIZE;
      ipos += HW_ELEM;
    }

  //end shared memory copy
  __syncthreads();

  //element treated by the given thread in n-axis
  thelem = par[idim].thelem[tid_hw] + par[idim].hwoffset_calc[hwid];
  //base element for the given thread in shared memory
  ShBaseElem = tid_hw + NUM_LINES*par[idim].hwoffset_calc[hwid];

  //output base element, from the input one
  BaseElem =  n*BaseElem+ thelem + elemOffset;

  //limit element for which the block treats unique elements

  //perform convolution in shared memory 
  //each thread calculate a number of elements, identical for each
  //half-warp

  for(int i=0;i < par[idim].hwelem_calc[hwid]; ++i)
    {
      //values of the convolution
      register T conv = 
	//hand-unrolled loop (16 elements for this filter)
	//order changed for increasing the precision
	MFIL0 *psi_sh[ShBaseElem               ] +
	MFIL15*psi_sh[ShBaseElem + 15*NUM_LINES] +
	MFIL1 *psi_sh[ShBaseElem +   NUM_LINES ] +
	MFIL14*psi_sh[ShBaseElem + 14*NUM_LINES] +
	MFIL2 *psi_sh[ShBaseElem + 2*NUM_LINES ] +
	MFIL13*psi_sh[ShBaseElem + 13*NUM_LINES] +
	MFIL3 *psi_sh[ShBaseElem + 3*NUM_LINES ] +
	MFIL12*psi_sh[ShBaseElem + 12*NUM_LINES] +
	MFIL4 *psi_sh[ShBaseElem + 4*NUM_LINES ] +
	MFIL11*psi_sh[ShBaseElem + 11*NUM_LINES] +
	MFIL5 *psi_sh[ShBaseElem + 5*NUM_LINES ] +
	MFIL10*psi_sh[ShBaseElem + 10*NUM_LINES] +
	MFIL6 *psi_sh[ShBaseElem + 6*NUM_LINES ] +
	MFIL9 *psi_sh[ShBaseElem + 9*NUM_LINES ] +
	MFIL7 *psi_sh[ShBaseElem + 7*NUM_LINES ] +
	MFIL8 *psi_sh[ShBaseElem + 8*NUM_LINES ] ;

      //register float v=tex1Dfetch(pot_tex,BaseElem);

      psi_out[BaseElem]=conv*pot[BaseElem];

      ShBaseElem += HALF_WARP_SIZE;
      BaseElem += HW_ELEM;
      
    }
 
}

//transposed convolution
template<typename T>
__global__ void magicfilter1d_t(int n,int ndat, T *psi_in, T *psi_out,int idim)
{

  //line treated by the given block
  unsigned int lineOffset = min(blockIdx.y*NUM_LINES,ndat-NUM_LINES);
  //starting element treated by the block
  unsigned int elemOffset = 
    min(blockIdx.x*par[idim].ElementsPerBlock,n-par[idim].ElementsPerBlock);

  //half-warp id
  const unsigned int hwid = threadIdx.y;
  //tid within the HW
  const unsigned int tid_hw = threadIdx.x;

  //shared memory array
  __shared__ T psi_sh[MAX_SHARED_SIZE/sizeof(T)];

  //line treated by the given thread in ndat axis
  //which is the input base element
  unsigned int BaseElem = par[idim].thline[tid_hw] + lineOffset;
  //write data in shared memory
  //element treated by the given thread in n-axis
  unsigned int thelem = par[idim].thelem[tid_hw] + par[idim].hwoffset_copy[hwid];

  unsigned int ShBaseElem = tid_hw + NUM_LINES*par[idim].hwoffset_copy[hwid];

  int epsilon,npos;

  //NOTE: it is assumed that for non-first segments the starting
  //points is far enough for the filter to be contained
  //and the same for non-last segments.
  //in other terms: lenght of the line is always bigger than
  //max(lowfil,lupfil)

  for(int i=0,ipos=elemOffset-LUPFILMF+thelem;i < par[idim].hwelem_copy[hwid] ; ++i)
    {
      epsilon=(ipos < 0 ? -1 : ipos/n);
      npos=ipos-epsilon*n;
      psi_sh[ShBaseElem]=psi_in[BaseElem+ndat*npos];
      //psi_sh[ShBaseElem]=tex1Dfetch(psi_tex,BaseElem+ndat*npos);

      ShBaseElem += HALF_WARP_SIZE;
      ipos += HW_ELEM;
      
    }

  //end shared memory copy
  __syncthreads();

  //element treated by the given thread in n-axis
  thelem = par[idim].thelem[tid_hw] + par[idim].hwoffset_calc[hwid];
  //base element for the given thread in shared memory
  ShBaseElem = tid_hw + NUM_LINES*par[idim].hwoffset_calc[hwid];

  //output base element, from the input one
  BaseElem =  n*BaseElem+ thelem + elemOffset;

  //perform convolution in shared memory 
  //each thread calculate a number of elements, identical for each
  //half-warp
  //#pragma unroll 5 (to be tested if it is important)

  for(int i=0;i < par[idim].hwelem_calc[hwid]; ++i)
    {
      //values of the convolution
      register T conv = 
	//hand-unrolled loop (16 elements for this filter)
	//order changed for increasing the precision
	MFIL15*psi_sh[ShBaseElem               ] +
	MFIL0 *psi_sh[ShBaseElem + 15*NUM_LINES] +
	MFIL14*psi_sh[ShBaseElem +   NUM_LINES ] +
	MFIL1 *psi_sh[ShBaseElem + 14*NUM_LINES] +
	MFIL13*psi_sh[ShBaseElem + 2*NUM_LINES ] +
	MFIL2 *psi_sh[ShBaseElem + 13*NUM_LINES] +
	MFIL12*psi_sh[ShBaseElem + 3*NUM_LINES ] +
	MFIL3 *psi_sh[ShBaseElem + 12*NUM_LINES] +
	MFIL11*psi_sh[ShBaseElem + 4*NUM_LINES ] +
	MFIL4 *psi_sh[ShBaseElem + 11*NUM_LINES] +
	MFIL10*psi_sh[ShBaseElem + 5*NUM_LINES ] +
	MFIL5 *psi_sh[ShBaseElem + 10*NUM_LINES] +
	MFIL9 *psi_sh[ShBaseElem + 6*NUM_LINES ] +
	MFIL6 *psi_sh[ShBaseElem + 9*NUM_LINES ] +
	MFIL8 *psi_sh[ShBaseElem + 7*NUM_LINES ] +
	MFIL7 *psi_sh[ShBaseElem + 8*NUM_LINES ] ;

      psi_out[BaseElem]=conv;
      //psi_sh[ShBaseElem+LOWFILMF*par[idim].LinesPerBlock]; //for testing only

      ShBaseElem += HALF_WARP_SIZE;
      BaseElem += HW_ELEM;
      
    }

 
}


template<typename T>
int magicfilterpot(int n1,int n2, int n3,
		   T *psi,
		   T *work,
		   T *pot,
		   T *epot)
{

  //create the parameters
  parGPU_t parCPU[3];

  //calculate the number of threads and blocks
  //unsigned int num_lines = min(16,ndat); //hard coded for the moment
  unsigned int numBlocks,linecuts,num_halfwarps;

  //calculate the parameters in constant memory for each of the 1D convolution
  //define the number of threads and blocks according to parameter definitions
  GPUParameters<T>(&parCPU[2],&num_halfwarps,n3,n1*n2,1,LOWFILMF,LUPFILMF,&linecuts,&numBlocks);
  dim3  grid3(linecuts,  numBlocks, 1);  
  dim3  threads3(HALF_WARP_SIZE, num_halfwarps , 1);

  //printf("num_blocksx %i, num_blocksy %i, halfwarps %i,n1,ndat, %i %i\n",
  //linecuts,numBlocks,num_halfwarps,n3,n1*n2);

  GPUParameters<T>(&parCPU[1],&num_halfwarps,n2,n1*n3,1,LOWFILMF,LUPFILMF,&linecuts,&numBlocks);
  dim3  grid2(linecuts,  numBlocks, 1);  
  dim3  threads2(HALF_WARP_SIZE, num_halfwarps , 1);

  //printf("num_blocksx %i, num_blocksy %i, halfwarps %i,n1,ndat, %i %i\n",
  //linecuts,numBlocks,num_halfwarps,n2,n1*n3);

  GPUParameters<T>(&parCPU[0],&num_halfwarps,n1,n2*n3,1,LOWFILMF,LUPFILMF,&linecuts,&numBlocks);
  dim3  grid1(linecuts,  numBlocks, 1);  
  dim3  threads1(HALF_WARP_SIZE, num_halfwarps , 1);

  //printf("num_blocksx %i, num_blocksy %i, halfwarps %i,n1,ndat, %i %i\n",
  //linecuts,numBlocks,num_halfwarps,n1,n3*n2);

  //send them to constant memory, once and for all
  if(cudaMemcpyToSymbol(*par,&parCPU, 3*sizeof(parGPU_t)) != 0)
    {
      printf("MemcpyToSymbol error\n");

      return 1;
    }

  //magicfilter1d <<< grid1, threads1 >>>(n1,n2*n3,psi,work,0);
  //cudaThreadSynchronize();


  //direct MF calculation

  //bind the texture reference to the input array
  //cudaBindTexture(NULL,psi_tex,GPU_idata,n*ndat*sizeof(float));

  //launch the kernel grid
  //conv1d_stride <<< grid1, threads1 >>>(n,ndat, GPU_odata);
  magicfilter1d<T> <<< grid3, threads3 >>>(n3,n1*n2,psi,work,2);
  //unbind the texture
  //cudaUnbindTexture(psi_tex);

  cudaThreadSynchronize();

  magicfilter1d<T> <<< grid2, threads2 >>>(n2,n1*n3,work,psi,1);
  cudaThreadSynchronize();

  magicfilter1d_pot<T> <<< grid1, threads1 >>>(n1,n2*n3,psi,pot,work,0);
  cudaThreadSynchronize();

  //here one should combine psi and work to calculate the potential
  //energy
  //reducearrays<T>(n1,n2*n3,psi,work,epot);
  //cudaThreadSynchronize(); //can be removed since the arrays are not overwritten

  //reverse MF calculation
  magicfilter1d_t<T> <<< grid3, threads3 >>>(n3,n1*n2,work,psi,2);
  cudaThreadSynchronize();

  magicfilter1d_t<T> <<< grid2, threads2 >>>(n2,n1*n3,psi,work,1);
  cudaThreadSynchronize();

  magicfilter1d_t<T> <<< grid1, threads1 >>>(n1,n2*n3,work,psi,0);
  cudaThreadSynchronize();

  return 0;

}

template<typename T>
int mf1d(int ndat, int n3,
	 T *psi,
	 T *out)
{

  //create the parameters
  parGPU_t parCPU[1];

  //calculate the number of threads and blocks
  //unsigned int num_lines = min(16,ndat); //hard coded for the moment
  unsigned int numBlocks,linecuts,num_halfwarps;

  //calculate the parameters in constant memory for each of the 1D convolution
  //define the number of threads and blocks according to parameter definitions
  GPUParameters<T>(&parCPU[0],&num_halfwarps,n3,ndat,1,LOWFILMF,LUPFILMF,&linecuts,&numBlocks);
  dim3  grid3(linecuts,  numBlocks, 1);  
  dim3  threads3(HALF_WARP_SIZE, num_halfwarps , 1);

  if(cudaMemcpyToSymbol(*par,&parCPU, sizeof(parGPU_t)) != 0)
    {
      printf("MemcpyToSymbol error\n");

      return 1;
    }

  magicfilter1d<T> <<< grid3, threads3 >>>(n3,ndat,psi,out,0);
  cudaThreadSynchronize();

  return 0;

}



#endif
