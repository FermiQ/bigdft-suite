#!/usr/bin/env python

##@file
## This script is used to wrap the @ref memguess executable  but also to perform
## some useful manipulations of atomic position files.
##@author
## Copyright (C) 2012-2013 BigDFT group
## This file is distributed under the terms of the
## GNU General Public License, see ~/COPYING file
## or http://www.gnu.org/copyleft/gpl.txt .
## For the list of contributors, see ~/AUTHORS


import sys
import os.path
import os
from optparse import OptionParser, OptionGroup

actions = ["memory-estimation", "rotate", "convert-field",
           "export-wf", "export-grid", "atomic-wf", "GPU-test","convert-positions","manual"]

srcdir = "@srcdir@"
inputvarfile= srcdir+'/input_variables_definition.yaml'
abs_top_builddir = "@abs_top_builddir@"
bindir = "@prefix@"

def toHelp(list):
  ret = ""
  for ele in list[:-1]:
    ret += ele + ", "
  ret += "or " + list[-1]
  return ret

def parse():
  "Parse the command line"
  parser = OptionParser("usage: bigdft-tool -a ACTION")
  parser.add_option("-a", "--action", default=actions[0],
                    help="perform one of the action: %s " % toHelp(actions) +
                    "[default: %default]. "
                    "Possible options for each action are described below.")
  parser.add_option("--name", type="string", default="", metavar="NAME",
                    help="read input files using NAME as radical [default: not specified]")

  # The memory estimation.
  group = OptionGroup(parser, "bigdft-tool -a %s [options]" % actions[0],
                      "Performing memory estimation for a run of BigDFT.")
  group.add_option("-n", "--n-proc", type="int", default=1, metavar="N",
                   help="provide the number of processors that should be"
                   " tested [default: %default]")
  parser.add_option_group(group)
  
  # The rotation.
  group = OptionGroup(parser, "bigdft-tool -a %s [options]" % actions[1],
                      "Rotate the input file to use the smallest mesh possible"
                      " using files following NAME scheme.")
  parser.add_option_group(group)

  # The field converter.
  group = OptionGroup(parser, "bigdft-tool -a %s FROM TO" % actions[2],
                      "Convert the given scalar field to another format, files"
                      " FROM and TO are of the form <file.{etsf,cube}>.")
  parser.add_option_group(group)

  # Wavefunction exportation.
  group = OptionGroup(parser, "bigdft-tool -a %s FILE" % actions[3],
                      "Export the compressed wavefunction from FILE to a scalar-field"
                      " representation in Cube format. If FILE is in ETSF format,"
                      " one should provide the characteristic of the orbital to export"
                      " with the following options.")
  group.add_option("--i-band", type="int", default=1, metavar="BAND",
                   help="choose the orbital to export [default: %default]")
  group.add_option("--i-kpt", type="int", default=1, metavar="KPT",
                   help="choose the k-point to export [default: %default]")
  group.add_option("--i-spin", type="int", default=1, metavar="SPIN",
                   help="choose the spin orientation to export [default: %default]")
  group.add_option("--i-complex", type="int", default=1, metavar="CPLX",
                   help="choose the real or imaginary part to export [default: %default]")
  parser.add_option_group(group)

  # Grid exportation
  group = OptionGroup(parser, "bigdft-tool -a %s [options]" % actions[4],
                      "Export in XYZ format the positions of all grid points.")
  parser.add_option_group(group)

  # GAtom
  group = OptionGroup(parser, "bigdft-tool -a %s [options]" % actions[5],
                      "Calculates the atomic wavefunctions of the first"
                      " atom in the gatom basis.")
  group.add_option("--n-gaussians", type="int", default=31, metavar="NUM", \
                    help="number of gaussians used in gatom calculation"
                   " in atomic-wf action [default: %default]")
  parser.add_option_group(group)

  # Test GPU speed
  group = OptionGroup(parser, "bigdft-tool -a %s [options]" % actions[6],
                      "Test the speed of 3D operators with GPU.")
  group.add_option("--n-repeats", type="int", default=5, metavar="NUM", \
                    help="number of repeated calculations in"
                   " GPU-test action [default: %default]")
  group.add_option("--n-orbs", type="int", default=0, metavar="NUM", \
                    help="limit the number of computed orbitals in"
                   " GPU-test action [default: %default]")
  parser.add_option_group(group)

  # Convert positions
  group = OptionGroup(parser, "bigdft-tool -a %s <input> <output>" % actions[7],
                    "Convert the <input> position file to the <output> format"
                    " the allowed formats are xyz, ascii and yaml")
  parser.add_option_group(group)

  # Manual
  group = OptionGroup(parser, "bigdft-tool -a %s [options]" % actions[8],
                      "Input file manual: helps in identifying the input variables which are interesting")
  group.add_option("--profile", type="str", default="single-point", metavar="NAME", \
                     help="Write a input file corresponding to profile named NAME")
  group.add_option("--find-key", type="str", default=None, metavar="NAME", \
                     help="Find the keys which are typographically similar to NAME")

  parser.add_option_group(group)


  return parser

def closest_keys(allkeys,searchfor):
  from difflib import SequenceMatcher
  matching_keys=[]
  # weight the keys which matches the most
  for k in allkeys:
    s=SequenceMatcher(lambda x: x == " ",searchfor,k)
    matching_keys.append([k,s.ratio()])
    matching_keys.sort(key=lambda x: x[1])
    matching_keys.reverse()
  return matching_keys

#find the fields which have this key
def find_files(parameters,key):
  files=[]
  for f in parameters:
    if key in parameters[f].keys():
      files.append(f)
  return files
    

if __name__ == "__main__":
  parser = parse()
  (options, args) = parser.parse_args()

  # Try to find memguess executable.
  memguess = None
  if os.path.isfile(os.path.join(os.path.dirname(sys.argv[0]), "memguess")):
    memguess = os.path.join(os.path.dirname(sys.argv[0]), "memguess")
  elif os.path.isfile("./memguess"):
    memguess = "./memguess"
  elif os.path.isfile(os.path.join(abs_top_builddir, "src", "memguess")):
    memguess = os.path.join(abs_top_builddir, "src", "memguess")
  elif os.path.isfile(os.path.join(bindir, "bin", "memguess")):
    memguess = os.path.join(bindir, "bin", "memguess")

  command=None 
  # Run memguess
  if options.action == actions[0]:
    command = "%s %d %s dd" % (memguess, options.n_proc, options.name)
  if options.action == actions[1]:
    command = "%s 1 %s dd o" % (memguess, options.name)
  if options.action == actions[2]:
    if len(args) < 2:
      parser.print_help()
      raise ValueError("Action '%s' requires two mandatory arguments" % actions[2])
    command = "%s 1 dd convert %s %s" % (memguess, args[0], args[1])
  if options.action == actions[3]:
    if len(args) < 1:
      parser.print_help()
      raise ValueError("Action '%s' requires one mandatory argument" % actions[3])
    command = "%s 1 %s dd exportwf %s %d %d %d %d" % (memguess, options.name, args[0], options.i_band, options.i_spin, options.i_kpt, options.i_complex)
  if options.action == actions[4]:
    command = "%s 1 %s dd y" % (memguess, options.name)
  if options.action == actions[5]:
    command = "%s 1 %s dd atwf %d" % (memguess, options.name, options.n_gaussians)
  if options.action == actions[6]:
    command = "%s 1 %s dd GPUtest %d %d" % (memguess, options.name, options.n_repeats, options.n_orbs)
  if options.action == actions[7]:
    if len(args) < 2:
      parser.print_help()
      raise ValueError("Action '%s' requires two mandatory arguments" % actions[7])
    command = "%s 1 dd convert-positions %s %s" % (memguess, args[0], args[1])
# input manual
  if options.action == actions[8]:
    #to parse and document the input variables
    import yaml
    try:
      fulldoc = [a for a in yaml.load_all(open(inputvarfile, "r").read(), Loader = yaml.CLoader)]
    except Exception,e:
      print str(e)
      print 'Error in opening input variable definition file, cannot proceed'
      sys.exit(1)
    params=fulldoc[0]
    files=params.keys()
    print 'Possible fields',files
    allkeys=[]
    for f in files:
      allkeys += params[f].keys()
    print ' Possible keys',allkeys
    # try to see if a key matches a expression
    if options.find_key is not None:
      searchfor=options.find_key
      matching_keys=closest_keys(allkeys,searchfor)
      print 'matching',searchfor,'in:',matching_keys
      print 'keys wich match the most with',searchfor
      foundkeys=[]
      doc=[]
      for (i,ratio) in matching_keys:
        if ratio > 0.5 and i not in foundkeys:
          for f in find_files(params,i):
            dc={}
            dc['Key found']=i
            dc['Similarity']=ratio
            dc['Field']=f
            dc['Description']=params[f][i]
            doc.append(dc)
            foundkeys.append(i)
      sys.stdout.write(yaml.dump(doc,default_flow_style=False,explicit_start=True))
    infiles=fulldoc[1]
    profs=infiles.keys()
    print 'Possible profiles:'
    for p in profs:
      print '-',p,infiles[p]["COMMENT"]
    print 'profile searched',options.profile
    if options.profile in profs:
      sys.stdout.write(yaml.dump(infiles[options.profile],default_flow_style=False,explicit_start=True))

  #print command
  #print 
  if command is not None:
    os.system(command)
