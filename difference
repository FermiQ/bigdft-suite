=== modified file 'PSolver/src/Makefile.am'
--- PSolver/src/Makefile.am	2015-06-18 13:40:44 +0000
+++ PSolver/src/Makefile.am	2015-03-23 11:31:27 +0000
@@ -106,7 +106,7 @@
 SUFFIXES = .cu
 
 NVCC = @NVCC@
-NVCC_FLAGS = -arch sm_20 @NVCC_FLAGS@
+NVCC_FLAGS = -arch sm_13 @NVCC_FLAGS@
 
 # Dynamic library building
 $(psolver_dynamic_library): $(libPSolver_1_a_OBJECTS)

=== modified file 'PSolver/src/PSolver_Main.f90'
--- PSolver/src/PSolver_Main.f90	2015-08-04 08:04:07 +0000
+++ PSolver/src/PSolver_Main.f90	2015-06-18 15:41:25 +0000
@@ -86,7 +86,7 @@
    !real(dp) :: scal
    real(dp), dimension(6) :: strten
    real(dp), dimension(:,:), allocatable :: rho,rhopol,x,q,p,r,z,depsdrho
-   real(dp), dimension(:,:,:), allocatable :: zf,work_full,pot_full
+   real(dp), dimension(:,:,:), allocatable :: zf,work_full
    !integer, dimension(:,:), allocatable :: gather_arr
 
    call f_routine(id='H_potential')
@@ -179,7 +179,6 @@
    !in the case of SC cavity, gather the full density and determine the depsdrho
    !here the if statement for the SC cavity should be put
    !print *,'method',trim(char(kernel%method)),associated(kernel%method%family),trim(char(kernel%method%family))
-   pot_full=f_malloc(kernel%ndims,id='pot_full')
    if (kernel%method .hasattr. PS_SCCS_ENUM) then
       work_full=f_malloc(kernel%ndims,id='work_full')
       depsdrho=f_malloc([n1,n23],id='depsdrho')
@@ -256,7 +255,6 @@
                     rhopol(i1,i23+i23s)
 !!$                       kernel%oneoeps(i1,i2,i3+i3s)*rho(i1,i2,i3)+&
 !!$                       rhopol(i1,i2,i3+i3s)
-               kernel%pol_charge(i1,i23)=rhopot(irho)-rho(i1,i23)
                irho=irho+1
             end do
          end do
@@ -331,7 +329,6 @@
       q=f_malloc0([n1,n23],id='q')
       p=f_malloc0([n1,n23],id='p')
       z=f_malloc([n1,n23],id='z')
-      rho=f_malloc([n1,n23],id='rho')
 
       if (wrtmsg) &
            call yaml_sequence_open('Embedded PSolver, Preconditioned Conjugate Gradient Method')
@@ -346,8 +343,6 @@
 
       call f_memcpy(n=kernel%grid%m1*kernel%grid%m3*kernel%grid%n3p,&
            src=rhopot(i3start),dest=r)
-      call f_memcpy(n=kernel%grid%m1*kernel%grid%m3*kernel%grid%n3p,&
-           src=rhopot(i3start),dest=rho)
 
       !$omp parallel do default(shared) private(i1,i23)
       do i23=1,n23
@@ -440,11 +435,6 @@
       if (kernel%method .hasattr. PS_SCCS_ENUM)&
            call extra_sccs_potential(kernel,work_full,depsdrho,x)
 
-!--------------------------------------
-! Polarization charge
-           call pol_charge(kernel,pot_full,rho,x)
-!--------------------------------------
-
       !here the harteee energy can be calculated and the ionic potential
       !added
       call finalize_hartree_results(sumpion,pot_ion,&
@@ -466,12 +456,10 @@
       call f_free(p)
       call f_free(q)
       call f_free(r)
-      call f_free(rho)
 
    end select
 
    call f_free(zf)
-   call f_free(pot_full)
 
    !if statement for SC cavity to be added
    if (kernel%method .hasattr. PS_SCCS_ENUM) then
@@ -547,26 +535,6 @@
   
 end subroutine extra_sccs_potential
 
-subroutine pol_charge(kernel,pot_full,rho,pot)
-  implicit none
-  type(coulomb_operator), intent(in) :: kernel
-  real(dp), dimension(kernel%ndims(1),kernel%ndims(2),kernel%ndims(3)), intent(out) :: pot_full
-  real(dp), dimension(kernel%ndims(1),kernel%ndims(2)*kernel%grid%n3p), intent(inout) :: rho
-  real(dp), dimension(kernel%ndims(1),kernel%ndims(2)*kernel%grid%n3p) :: pot !intent in
-
-  !first gather the potential to calculate the derivative
-  if (kernel%mpi_env%nproc > 1) then
-     call mpiallgather(pot,recvbuf=pot_full,recvcounts=kernel%counts,&
-          displs=kernel%displs,comm=kernel%mpi_env%mpi_comm)
-  else
-     call f_memcpy(src=pot,dest=pot_full)
-  end if
-
-  !lculate the extra potential and add it to pot
-  call polarization_charge(kernel,pot_full,rho)
-  
-end subroutine pol_charge
-
 !> verify that the density is considerably zero in the region where epsilon is different from one
 subroutine nonvacuum_projection(n1,n23,rho,oneoeps,norm)
   implicit none

=== modified file 'PSolver/src/Poisson_Solver.f90'
--- PSolver/src/Poisson_Solver.f90	2015-08-04 08:04:07 +0000
+++ PSolver/src/Poisson_Solver.f90	2015-06-16 10:20:29 +0000
@@ -166,10 +166,6 @@
       !> inner rigid cavity to be integrated in the sccs method to avoit inner
       !! cavity discontinuity due to near-zero edens near atoms
       real(dp), dimension(:,:), pointer :: epsinnersccs
-      !> Polarization charge vector for print purpose only.
-      real(dp), dimension(:,:), pointer :: pol_charge
-      !> Dielectric cavity eps for print purpose only.
-      real(dp), dimension(:,:), pointer :: cavity
       real(dp) :: work1_GPU,work2_GPU,k_GPU !<addresses for the GPU memory 
       integer, dimension(5) :: plan
       integer, dimension(3) :: geo
@@ -258,8 +254,6 @@
     nullify(k%oneoeps)
     nullify(k%corr)
     nullify(k%epsinnersccs)
-    nullify(k%pol_charge)
-    nullify(k%cavity)
     k%work1_GPU=0.d0
     k%work2_GPU=0.d0
     k%k_GPU=0.d0

=== modified file 'PSolver/src/createKernel.f90'
--- PSolver/src/createKernel.f90	2015-08-04 08:04:07 +0000
+++ PSolver/src/createKernel.f90	2015-06-18 15:41:25 +0000
@@ -79,7 +79,7 @@
         kernel%PI_eta=0.6_dp
      case('PCG')
         kernel%method=PS_PCG_ENUM
-        kernel%nord=16
+        kernel%nord=16 
         kernel%max_iter=50
         kernel%minres=1.0e-6_dp!1.0e-12_dp
      case default
@@ -168,8 +168,6 @@
   call f_free_ptr(kernel%oneoeps)
   call f_free_ptr(kernel%corr)
   call f_free_ptr(kernel%epsinnersccs)
-  call f_free_ptr(kernel%pol_charge)
-  call f_free_ptr(kernel%cavity)
   call f_free_ptr(kernel%counts)
   call f_free_ptr(kernel%displs)
 
@@ -835,8 +833,6 @@
   if (kernel%grid%n3p==0) i3s=1
   select case(trim(str(kernel%method)))
   case('PCG')
-     kernel%cavity=f_malloc_ptr([n1,n23],id='cavity')
-     kernel%pol_charge=f_malloc_ptr([n1,n23],id='pol_charge')
      if (present(corr)) then
         kernel%corr=f_malloc_ptr([n1,n23],id='corr')
         call f_memcpy(n=n1*n23,src=corr(1,1,i3s),dest=kernel%corr)
@@ -889,8 +885,6 @@
         call f_err_throw('For method "PCG" the arrays oneosqrteps or epsilon should be present')   
      end if
   case('PI')
-     kernel%cavity=f_malloc_ptr([n1,n23],id='cavity')
-     kernel%pol_charge=f_malloc_ptr([n1,n23],id='pol_charge')
      if (present(dlogeps)) then
         !kernel%dlogeps=f_malloc_ptr(src=dlogeps,id='dlogeps')
         kernel%dlogeps=f_malloc_ptr(shape(dlogeps),id='dlogeps')
@@ -955,15 +949,11 @@
      kernel%corr=f_malloc_ptr([n1,n23],id='corr')
      kernel%oneoeps=f_malloc_ptr([n1,n23],id='oneosqrteps')
      kernel%epsinnersccs=f_malloc_ptr([n1,n23],id='epsinnersccs')
-     kernel%pol_charge=f_malloc_ptr([n1,n23],id='pol_charge')
-     kernel%cavity=f_malloc_ptr([n1,n23],id='cavity')
   case('PI')
      kernel%dlogeps=f_malloc_ptr([3,kernel%ndims(1),kernel%ndims(2),kernel%ndims(3)],&
           id='dlogeps')
      kernel%oneoeps=f_malloc_ptr([n1,n23],id='oneoeps')
      kernel%epsinnersccs=f_malloc_ptr([n1,n23],id='epsinnersccs')
-     kernel%pol_charge=f_malloc_ptr([n1,n23],id='pol_charge')
-     kernel%cavity=f_malloc_ptr([n1,n23],id='cavity')
   end select
   if (present(vacuum)) then
      if (vacuum) then
@@ -974,8 +964,6 @@
            call f_zero(kernel%dlogeps)
         end select
         call f_zero(kernel%epsinnersccs)
-        call f_zero(kernel%pol_charge)
-        call f_zero(kernel%cavity)
         do i23=1,n23
            do i1=1,n1
               kernel%oneoeps(i1,i23)=1.0_dp
@@ -988,17 +976,15 @@
 
 !>put in depsdrho array the extra potential
 subroutine sccs_extra_potential(kernel,pot,depsdrho)
-  use yaml_output
   implicit none
   type(coulomb_operator), intent(in) :: kernel
   !>complete potential, needed to calculate the derivative
   real(dp), dimension(kernel%ndims(1),kernel%ndims(2),kernel%ndims(3)), intent(in) :: pot
   real(dp), dimension(kernel%ndims(1),kernel%ndims(2)*kernel%grid%n3p), intent(inout) :: depsdrho
   !local variables
-  integer :: i3,i3s,i2,i1,i23,i,n01,n02,n03,unt
-  real(dp) :: d2,x
+  integer :: i3,i3s,i2,i1,i23,i,n01,n02,n03
+  real(dp) :: d2
   real(dp), dimension(:,:,:,:), allocatable :: nabla_pot
-  real(dp), dimension(kernel%ndims(1),kernel%ndims(2),kernel%ndims(3)) :: pot2,depsdrho1,depsdrho2
 
   n01=kernel%ndims(1)
   n02=kernel%ndims(2)
@@ -1018,76 +1004,19 @@
            do i=1,3
               d2 = d2+nabla_pot(i1,i2,i3,i)**2
            end do
-           depsdrho1(i1,i2,i3)=depsdrho(i1,i23)
            depsdrho(i1,i23)=depsdrho(i1,i23)*d2
-           pot2(i1,i2,i3)=d2
-           depsdrho2(i1,i2,i3)=depsdrho(i1,i23)
         end do
         i23=i23+1
      end do
   end do
-
-!     unt=f_get_free_unit(22)
-!     call f_open_file(unt,file='extra_term_line_sccs_x.dat')
-!     do i1=1,n01
-!        x=i1*kernel%hgrids(1)
-!        write(unt,'(1x,I8,5(1x,e22.15))')i1,x,pot(i1,n02/2,n03/2),depsdrho1(i1,n02/2,n03/2),pot2(i1,n02/2,n03/2),depsdrho2(i1,n02/2,n03/2)
-!     end do
-!     call f_close(unt)
  
   call f_free(nabla_pot)
-!  call yaml_map('extra term here',.true.)
 
   if (kernel%mpi_env%iproc==0 .and. kernel%mpi_env%igroup==0) &
        call yaml_map('Extra SCF potential calculated',.true.)
 
 end subroutine sccs_extra_potential
 
-!>put in pol_charge array the polarization charge
-subroutine polarization_charge(kernel,pot,rho)
-  implicit none
-  type(coulomb_operator), intent(in) :: kernel
-  !>complete potential, needed to calculate the derivative
-  real(dp), dimension(kernel%ndims(1),kernel%ndims(2),kernel%ndims(3)), intent(in) :: pot
-  real(dp), dimension(kernel%ndims(1),kernel%ndims(2)*kernel%grid%n3p), intent(inout) :: rho
-  !local variables
-  integer :: i3,i3s,i2,i1,i23,i,n01,n02,n03
-  real(dp) :: d2,pi
-  real(dp), dimension(:,:,:,:), allocatable :: nabla_pot
-  real(dp), dimension(:,:,:), allocatable :: lapla_pot
-
-  pi=4.0_dp*atan(1.0_dp)
-  n01=kernel%ndims(1)
-  n02=kernel%ndims(2)
-  n03=kernel%ndims(3)
-  !starting point in third direction
-  i3s=kernel%grid%istart+1
-
-  nabla_pot=f_malloc([n01,n02,n03,3],id='nabla_pot')
-  lapla_pot=f_malloc([n01,n02,n03],id='lapla_pot')
-  !calculate derivative of the potential
-  call fssnord3DmatNabla3var_LG(kernel%geocode,n01,n02,n03,pot,nabla_pot,kernel%nord,kernel%hgrids)
-  call fssnord3DmatDiv3var_LG(kernel%geocode,n01,n02,n03,nabla_pot,lapla_pot,kernel%nord,kernel%hgrids)
-  i23=1
-  do i3=i3s,i3s+kernel%grid%n3p-1!kernel%ndims(3)
-     do i2=1,n02
-        do i1=1,n01
-           !this section has to be inserted into a optimized calculation of the
-           !derivative
-           kernel%pol_charge(i1,i23)=(-0.25_dp/pi)*lapla_pot(i1,i2,i3)-rho(i1,i23)
-        end do
-        i23=i23+1
-     end do
-  end do
-
-  call f_free(nabla_pot)
-  call f_free(lapla_pot)
-
-  if (kernel%mpi_env%iproc==0 .and. kernel%mpi_env%igroup==0) &
-       call yaml_map('Polarization charge calculated',.true.)
-
-end subroutine polarization_charge
-
 !>build the needed arrays of the cavity from a given density
 !!according to the SCF cavity definition given by Andreussi et al. JCP 136, 064102 (2012)
 !! @warning: for the moment the density is supposed to be not distributed as the 
@@ -1110,13 +1039,13 @@
 
   
   !local variables
-  logical, parameter :: dumpeps=.true.  !.true.
-  real(kind=8), parameter :: edensmax = 0.005d0 !0.0050d0
+  logical, parameter :: dumpeps=.false.  !.true.
+  real(kind=8), parameter :: edensmax = 0.0050d0
   real(kind=8), parameter :: edensmin = 0.0001d0
   real(kind=8), parameter :: innervalue = 0.9d0
   integer :: n01,n02,n03,i,i1,i2,i3,i23,i3s,unt
   real(dp) :: oneoeps0,oneosqrteps0,pi,coeff,coeff1,fact1,fact2,fact3,r,t,d2,dtx,dd,x,y,z
-  real(dp), dimension(:,:,:), allocatable :: ddt_edens,epscurr,epsinner,depsdrho1
+  real(dp), dimension(:,:,:), allocatable :: ddt_edens,epscurr,epsinner
   real(dp), dimension(:,:,:,:), allocatable :: nabla_edens
 
   n01=kernel%ndims(1)
@@ -1129,7 +1058,6 @@
   nabla_edens=f_malloc([n01,n02,n03,3],id='nabla_edens')
   ddt_edens=f_malloc(kernel%ndims,id='ddt_edens')
   epsinner=f_malloc(kernel%ndims,id='epsinner')
-  depsdrho1=f_malloc(kernel%ndims,id='depsdrho1')
   if (dumpeps) epscurr=f_malloc(kernel%ndims,id='epscurr')
 
   !build the gradients and the laplacian of the density
@@ -1160,7 +1088,6 @@
            do i1=1,n01
              if (kernel%epsinnersccs(i1,i23).gt.innervalue) then ! Check for inner sccs cavity value to fix as vacuum
                  !eps(i1,i2,i3)=1.d0
-                 kernel%cavity(i1,i23)=1.d0
                  if (dumpeps) epscurr(i1,i2,i3)=1.d0
                  kernel%oneoeps(i1,i23)=1.d0 !oneosqrteps(i1,i2,i3)
 !!$                 do i=1,3
@@ -1168,12 +1095,10 @@
 !!$                 end do
                  kernel%corr(i1,i23)=0.d0 !corr(i1,i2,i3)
                  depsdrho(i1,i23)=0.d0
-                 depsdrho1(i1,i2,i3)=0.d0
              else
 
               if (dabs(edens(i1,i2,i3)).gt.edensmax) then
                  !eps(i1,i2,i3)=1.d0
-                 kernel%cavity(i1,i23)=1.d0
                  if (dumpeps) epscurr(i1,i2,i3)=1.d0
                  kernel%oneoeps(i1,i23)=1.d0 !oneosqrteps(i1,i2,i3)
 !!$                 do i=1,3
@@ -1181,10 +1106,8 @@
 !!$                 end do
                  kernel%corr(i1,i23)=0.d0 !corr(i1,i2,i3)
                  depsdrho(i1,i23)=0.d0
-                 depsdrho1(i1,i2,i3)=0.d0
               else if (dabs(edens(i1,i2,i3)).lt.edensmin) then
                  !eps(i1,i2,i3)=eps0
-                 kernel%cavity(i1,i23)=eps0
                  if (dumpeps) epscurr(i1,i2,i3)=eps0
                  kernel%oneoeps(i1,i23)=oneosqrteps0 !oneosqrteps(i1,i2,i3)
 !!$                 do i=1,3
@@ -1192,18 +1115,15 @@
 !!$                 end do
                  kernel%corr(i1,i23)=0.d0 !corr(i1,i2,i3)
                  depsdrho(i1,i23)=0.d0
-                 depsdrho1(i1,i2,i3)=0.d0
               else
                  r=fact1*(log(edensmax)-log(dabs(edens(i1,i2,i3))))
                  t=fact2*(r-sin(r))
                  !eps(i1,i2,i3)=exp(t)
-                 kernel%cavity(i1,i23)=safe_exp(t)
                  if (dumpeps) epscurr(i1,i2,i3)=safe_exp(t)
                  kernel%oneoeps(i1,i23)=safe_exp(-0.5d0*t) !oneosqrteps(i1,i2,i3)
                  coeff=fact3*(1.d0-cos(r))
                  dtx=-coeff/dabs(edens(i1,i2,i3))
                  depsdrho(i1,i23)=-safe_exp(t)*0.125d0/pi*dtx
-                 depsdrho1(i1,i2,i3)=-safe_exp(t)*0.125d0/pi*dtx
                  d2=0.d0
                  do i=1,3
                     !dlogeps(i,i1,i2,i3)=dtx*nabla_edens(i1,i2,i3,isp,i)
@@ -1229,7 +1149,6 @@
              epsinner(i1,i2,i3)=kernel%epsinnersccs(i1,i23)
              if (kernel%epsinnersccs(i1,i23).gt.innervalue) then ! Check for inner sccs cavity value to fix as vacuum
                  !eps(i1,i2,i3)=1.d0
-                 kernel%cavity(i1,i23)=1.d0
                  if (dumpeps) epscurr(i1,i2,i3)=1.d0
                  kernel%oneoeps(i1,i23)=1.d0 !oneoeps(i1,i2,i3)
                  depsdrho(i1,i23)=0.d0
@@ -1237,13 +1156,11 @@
 
               if (dabs(edens(i1,i2,i3)).gt.edensmax) then
                  !eps(i1,i2,i3)=1.d0
-                 kernel%cavity(i1,i23)=1.d0
                  if (dumpeps) epscurr(i1,i2,i3)=1.d0
                  kernel%oneoeps(i1,i23)=1.d0 !oneoeps(i1,i2,i3)
                  depsdrho(i1,i23)=0.d0
               else if (dabs(edens(i1,i2,i3)).lt.edensmin) then
                  !eps(i1,i2,i3)=eps0
-                 kernel%cavity(i1,i23)=eps0
                  if (dumpeps) epscurr(i1,i2,i3)=eps0
                  kernel%oneoeps(i1,i23)=oneoeps0 !oneoeps(i1,i2,i3)
                  depsdrho(i1,i23)=0.d0
@@ -1253,7 +1170,6 @@
                  coeff=fact3*(1.d0-cos(r))
                  dtx=-coeff/dabs(edens(i1,i2,i3))
                  depsdrho(i1,i23)=-safe_exp(t)*0.125d0/pi*dtx
-                 kernel%cavity(i1,i23)=safe_exp(t)
                  !eps(i1,i2,i3)=dexp(t)
                  if (dumpeps) epscurr(i1,i2,i3)=safe_exp(t)
                  kernel%oneoeps(i1,i23)=safe_exp(-t) !oneoeps(i1,i2,i3)
@@ -1315,7 +1231,7 @@
      call f_open_file(unt,file='epsilon_line_sccs_x.dat')
      do i1=1,n01
         x=i1*kernel%hgrids(1)
-        write(unt,'(1x,I8,4(1x,e22.15))')i1,x,epscurr(i1,n02/2,n03/2),edens(i1,n02/2,n03/2),depsdrho1(i1,n02/2,n03/2)
+        write(unt,'(1x,I8,3(1x,e22.15))')i1,x,epscurr(i1,n02/2,n03/2),edens(i1,n02/2,n03/2)
      end do
      call f_close(unt)
 
@@ -1342,7 +1258,6 @@
   call f_free(ddt_edens)
   call f_free(nabla_edens)
   call f_free(epsinner)
-  call f_free(depsdrho1)
 
 end subroutine pkernel_build_epsilon
   

=== modified file 'PSolver/src/cufft.cu'
--- PSolver/src/cufft.cu	2015-06-18 13:40:44 +0000
+++ PSolver/src/cufft.cu	2014-02-10 10:48:23 +0000
@@ -28,19 +28,19 @@
 }
 
 // allocate device memory
-extern "C" void FC_FUNC(cudamalloc, CUDAMALLOC) (int *size, Real **d_data,int *ierr) {
+extern "C" void cudamalloc_(int *size, Real **d_data,int *ierr) {
 
   *ierr = cudaMalloc((void**)d_data, sizeof(Real)*(*size));
   if( cudaGetLastError() != cudaSuccess)
       printf("allocate error\n");
 }
 
-extern "C" void FC_FUNC(cudafree, CUDAFREE) (Real **d_data) {
+extern "C" void cudafree_(Real **d_data) {
 
   cudaFree(*d_data);
 }
 
-extern "C" void FC_FUNC(cufftdestroy, CUFFTDESTROY) (cufftHandle *plan) {
+extern "C" void cufftdestroy_(cufftHandle *plan) {
 
   cufftDestroy(*plan);
 }

=== modified file 'PSolver/tests/Generalized_PSolver.f90'
--- PSolver/tests/Generalized_PSolver.f90	2015-08-04 08:04:07 +0000
+++ PSolver/tests/Generalized_PSolver.f90	2015-06-15 08:00:40 +0000
@@ -23,7 +23,6 @@
    ! To set 1 for analytical epsilon, 2 for analytical electron dependence,
    ! 3 for real electron density from cube file, 4 for rigid cavity.
    integer :: SetEps! = 1!3 
-   logical :: usegpu
 
    real(kind=8), parameter :: acell = 10.d0
    real(kind=8), parameter :: rad_cav = 1.7d0 ! Radius of the dielectric rigid cavity = rad_cav*acell (with nat=1).
@@ -53,7 +52,7 @@
 
    ! Now start modification for check.
    real(kind=8), dimension(:,:,:,:,:), allocatable :: dens_check,pot_check
-   integer :: i_check,unt,igpu
+   integer :: i_check,unt
    ! To set 1 for normal run, 3 for check V[\rho,\epsilon] + V[\rho_ion,epsilon] is = to V[\rho + \rho_ion, epsilon]
    integer, parameter :: n_check = 1 
 
@@ -89,14 +88,8 @@
 !!$giu
    geocode=options//'geocode'
    SetEps =options//'seteps'
-   usegpu = options // 'accel'
    call dict_free(options)
 
-
-   igpu=0
-   if (usegpu) igpu=1
-   igpu=0
-
    n01=ndims(1)
    n02=ndims(2)
    n03=ndims(3)
@@ -185,12 +178,12 @@
    else
     if (nat.eq.1) then
      delta=0.3d0 !6.d0*max(hx,hy,hz)
-     rxyz(1,1) = hx*real(n01/2,kind=8)
+!     rxyz(1,1) = hx*real(n01/2,kind=8)
      rxyz(2,1) = hy*real(n02/2,kind=8)
-     rxyz(3,1) = hz*real(n03/2,kind=8)
-!     rxyz(1,1) = hx*real(10,kind=8)
+!     rxyz(3,1) = hz*real(n03/2,kind=8)
+     rxyz(1,1) = hx*real(10,kind=8)
 !     rxyz(2,1) = hy*real(10,kind=8)
-!     rxyz(3,1) = hz*real(10,kind=8)
+     rxyz(3,1) = hz*real(10,kind=8)
      radii(1)=rad_cav!*1.5d0/0.52917721092d0
     else if (nat.eq.2) then
      delta=0.3d0 !6.d0*max(hx,hy,hz)
@@ -257,10 +250,8 @@
 !   corr=0.d0
 
    ! Set initial density, and the associated analitical potential for the Standard Poisson Equation.
-   call SetInitDensPot(n01,n02,n03,nspden,iproc,nat,eps,dlogeps,sigmaeps,SetEps,&
-        erfL,erfR,acell,a_gauss,a2,hx,hy,hz,Setrho,density,potential,geocode,offset,einit,multp,rxyz)
-!   call SetInitDensPot(n01,n02,n03,nspden,iproc,eps,dlogeps,sigmaeps,1,erfL,erfR,&
-!   acell,a_gauss,a2,hx,hy,hz,1,density,potential,geocode,offset,einit,multp)
+   call SetInitDensPot(n01,n02,n03,nspden,iproc,nat,eps,dlogeps,sigmaeps,SetEps,erfL,erfR,acell,a_gauss,a2,hx,hy,hz,Setrho,density,potential,geocode,offset,einit,multp,rxyz)
+!   call SetInitDensPot(n01,n02,n03,nspden,iproc,eps,dlogeps,sigmaeps,1,erfL,erfR,acell,a_gauss,a2,hx,hy,hz,1,density,potential,geocode,offset,einit,multp)
 
 !   eps=1.d0
 !   corr=0.d0
@@ -329,7 +320,7 @@
 !  end if
 
   !new method
-  pkernel=pkernel_init(.true.,iproc,nproc,igpu,geocode,ndims,hgrids,itype_scf,alg=PSol)
+  pkernel=pkernel_init(.true.,iproc,nproc,0,geocode,ndims,hgrids,itype_scf,alg=PSol)
   call pkernel_set(pkernel,verbose=.true.)
 
   if ( trim(PSol)=='PCG') then
@@ -386,13 +377,11 @@
   if (any(SetEps == [2,3,4])) then
    call H_potential('G',pkernel,rhopot,rhopot,ehartree,offset,.false.)
   else if (any(SetEps == [5])) then
-  call Prec_conjugate_gradient(n01,n02,n03,nspden,iproc,hx,hy,hz,rhopot,acell,&
-       eps,SetEps,nord,pkernel,potential,corr,oneosqrteps,multp,offset,geocode)
+  call Prec_conjugate_gradient(n01,n02,n03,nspden,iproc,hx,hy,hz,rhopot,acell,eps,SetEps,nord,pkernel,potential,corr,oneosqrteps,multp,offset,geocode)
 !  call PolarizationIteration(n01,n02,n03,nspden,iproc,hx,hy,hz,rhopot,acell,eps,nord,pkernel,potential,oneoeps,dlogeps,multp,offset,geocode)
   else if (any(SetEps == [6])) then
-!   call Poisson_Boltzmann(n01,n02,n03,nspden,iproc,hx,hy,hz,rhopot,acell,eps,SetEps,nord,pkernel,potential,corr,oneosqrteps,multp)
-!   call Poisson_Boltzmann_improved(n01,n02,n03,nspden,iproc,hx,hy,hz,rhopot,acell,eps,SetEps,nord,pkernel,potential,corr,oneosqrteps,multp)
-   call Poisson_Boltzmann_improved2(n01,n02,n03,nspden,iproc,hx,hy,hz,rhopot,acell,eps,SetEps,nord,pkernel,potential,corr,oneosqrteps,multp)
+   call Poisson_Boltzmann(n01,n02,n03,nspden,iproc,hx,hy,hz,rhopot,acell,eps,SetEps,nord,pkernel,potential,corr,oneosqrteps,multp)
+!   call Poisson_Boltzmann_improved(n01,n02,n03,nspden,iproc,hx,hy,hz,rhopot,acell,eps,6,nord,pkernel,potential,corr,oneosqrteps,multp)
   end if
 
   pot_check(:,:,:,:,i_check) = rhopot(:,:,:,:)
@@ -590,10 +579,6 @@
                 '2' .is. 'analytical electron dependence',&
                 '3' .is. 'real electron density from cube file (need electroninc_density.cube)')))
 
-  call yaml_cl_parse_option(parser,'accel','No',&
-       'GPU Acceleration','a',&
-       dict_new('Usage' .is. &
-       'Boolean, set the GPU acceleration'))
 
 end subroutine PS_Check_options
 
@@ -614,7 +599,7 @@
   !local variables
   integer :: i,unt,n
   real(kind=8) :: PB_charge,v,dv
-  integer, parameter :: n_points = 20001
+  integer, parameter :: n_points = 2001
   real(kind=8), parameter :: length = 1.d0 ! One side length.
   real(kind=8), dimension(n_points) :: func
 
@@ -651,8 +636,7 @@
   real(8), dimension(n_ions) :: c_max  !< maximum local concentration that ionic species can attain [mol/m^3]
   real(8), dimension(n_ions) :: r_ions !< effective ionic radius of ionic species [m]
   real(8), parameter :: Temp = 300 ! Temperature of the liquid system [K]
-  !> packing coefficient p = 1 for perfect packing, p = pi_greek/(3(2)^{1/2}) ≈ 0.74 for close packing,
-  real(8), parameter :: p = 0.74d0 
+  real(8), parameter :: p = 0.74d0 !< packing coefficient p = 1 for perfect packing, p = pi_greek/(3(2)^{1/2}) ≈ 0.74 for close packing,
                                    !! p ≈ 0.64 for random close packing, and p = pi_greek/6 ≈ 0.52 for simple cubic packing.
   ! Nedeed constant
   real(8), parameter :: n_avo = 6.0221412927d23 ! Avogadro's number [1/mol]
@@ -713,8 +697,7 @@
 
 end function PB_charge
 
-subroutine PolarizationIteration(n01,n02,n03,nspden,iproc,&
-     hx,hy,hz,b,acell,eps,nord,pkernel,potential,oneoeps,dlogeps,multp,offset,geocode)
+subroutine PolarizationIteration(n01,n02,n03,nspden,iproc,hx,hy,hz,b,acell,eps,nord,pkernel,potential,oneoeps,dlogeps,multp,offset,geocode)
   use yaml_output
   use Poisson_Solver
   use wrapper_linalg
@@ -911,8 +894,7 @@
 
 end subroutine PolarizationIteration
 
-subroutine Prec_conjugate_gradient(n01,n02,n03,nspden,iproc,hx,hy,hz,b,&
-     acell,eps,SetEps,nord,pkernel,potential,corr3,oneosqrteps,multp,offset,geocode)
+subroutine Prec_conjugate_gradient(n01,n02,n03,nspden,iproc,hx,hy,hz,b,acell,eps,SetEps,nord,pkernel,potential,corr3,oneosqrteps,multp,offset,geocode)
 
   use Poisson_Solver
   use yaml_output
@@ -1592,8 +1574,7 @@
 
 end subroutine Poisson_Boltzmann
 
-subroutine Poisson_Boltzmann_improved(n01,n02,n03,nspden,iproc,hx,hy,hz,b,&
-     acell,eps,SetEps,nord,pkernel,potential,corr3,oneosqrteps,multp)
+subroutine Poisson_Boltzmann_improved(n01,n02,n03,nspden,iproc,hx,hy,hz,b,acell,eps,SetEps,nord,pkernel,potential,corr3,oneosqrteps,multp)
 
   use Poisson_Solver
   use yaml_output
@@ -1924,352 +1905,6 @@
 
 end subroutine Poisson_Boltzmann_improved
 
-subroutine Poisson_Boltzmann_improved2(n01,n02,n03,nspden,iproc,hx,hy,hz,b,&
-     acell,eps,SetEps,nord,pkernel,potential,corr3,oneosqrteps,multp)
-
-  use Poisson_Solver
-  use yaml_output
-  use f_utils
-  use dynamic_memory
-  implicit none
-  integer, intent(in) :: n01
-  integer, intent(in) :: n02
-  integer, intent(in) :: n03
-  integer, intent(in) :: nspden,iproc
-  real(kind=8), intent(in) :: hx,hy,hz
-  integer, intent(in) :: nord
-  real(kind=8), intent(in) :: acell,multp
-  type(coulomb_operator), intent(inout) :: pkernel
-  real(kind=8), dimension(n01,n02,n03), intent(in) :: eps
-  integer, intent(in) :: SetEps
-  real(kind=8), dimension(n01,n02,n03), intent(in) :: potential,corr3,oneosqrteps
-  real(kind=8), dimension(n01,n02,n03,nspden), intent(inout) :: b
-
-  real(kind=8), dimension(:,:,:,:), allocatable :: x,r,z,p,q,qold,lv,corr,deps,r_PB,x_PB,x_check
-  !real(kind=8), dimension(n01,n02,n03,3) :: deps
-  real(kind=8), dimension(:,:,:), allocatable :: de2,ddeps
-  integer, parameter :: max_iter = 50
-  integer, parameter :: max_iter_PB = 150
-  real(kind=8), parameter :: max_ratioex = 1.0d10
-  real(kind=8), parameter :: max_ratioex_PB = 1.0d10
-  real(kind=8) :: alpha,beta,beta0,betanew,normb,normr,ratio,k,epsc,zeta,pval,qval,rval,pbval,multvar
-  integer :: i,ii,j,i1,i2,i3,isp,i_PB
-  real(kind=8), parameter :: error = 1.0d-10 !1.0d-13
-  real(kind=8), parameter :: eps0 = 78.36d0
-  real(kind=8), parameter :: eta = 1.0d0 ! Mixing parameter for the Poisson-Boltzmann ionic charge.
-  real(kind=8), parameter :: tauPB = 1.0d-10 ! Exit of Poisson-Boltzmann loop, to be = error for GPE.
-  real(kind=8), dimension(n01,n02,n03) ::pot_ion
-  real(kind=8) :: ehartree,offset,pi,switch,rpoints,res,rho,rhores2,normrPB,errorvar
-  real(kind=8) :: PB_charge
-
-  !allocate heap arrays
-  x=f_malloc([n01,n02,n03,nspden],id='x')
-  r=f_malloc([n01,n02,n03,nspden],id='r')
-  z=f_malloc([n01,n02,n03,nspden],id='z')
-  p=f_malloc([n01,n02,n03,nspden],id='p')
-  q=f_malloc([n01,n02,n03,nspden],id='q')
-  qold=f_malloc([n01,n02,n03,nspden],id='qold')
-  lv=f_malloc([n01,n02,n03,nspden],id='lv')
-  corr=f_malloc([n01,n02,n03,nspden],id='corr')
-  deps=f_malloc([n01,n02,n03,3],id='deps')
-  ddeps=f_malloc([n01,n02,n03],id='ddeps')
-  de2=f_malloc([n01,n02,n03],id='de2')
-  r_PB=f_malloc([n01,n02,n03,nspden],id='r_PB')
-  x_PB=f_malloc([n01,n02,n03,nspden],id='x_PB')
-  x_check=f_malloc([n01,n02,n03,nspden],id='x_check')
-
-  pi = 4.d0*datan(1.d0)   
-  rpoints=product(real([n01,n02,n03],kind=8))
-
-  open(unit=18,file='PBimpro_PCG_normr.dat',status='unknown')
-  open(unit=38,file='PCGimpro_accuracy.dat',status='unknown')
-
-  if (iproc ==0) then
-   write(18,'(1x,a)')'iter_PB normrPB rhores2'
-   write(38,'(1x,a)')'iter i1_max i2_max i3_max max_val max_center'
-   call yaml_map('rpoints',rpoints)
-   call yaml_sequence_open('Embedded PSolver, Preconditioned Conjugate Gradient Method')
-  end if
-
-  switch=0.0d0
-  if (SetEps.eq.6) then
-   switch=1.0d0
-  end if
-
-!--------------------------------------------------------------------------------------------
-! Set the correction vector for the Generalized Laplace operator
-
-!  call fssnordEpsilonDerivative(n01,n02,n03,nspden,hx,hy,hz,eps,de2,ddeps,nord,acell)
-
-!  call fssnord3DmatNabla3varde2(n01,n02,n03,nspden,hx,hy,hx,eps,deps,de2,nord,acell)
-!  call fssnord3DmatDiv3var(n01,n02,n03,nspden,hx,hy,hz,deps,ddeps,nord,acell)
-
-!  isp=1
-!  do i3=1,n03
-!   do i2=1,n02
-!    do i1=1,n01
-!     corr(i1,i2,i3,isp)=(-0.125d0/pi)*(0.5d0*de2(i1,i2,i3)/eps(i1,i2,i3)-ddeps(i1,i2,i3))
-!    end do
-!   end do
-!  end do
-!--------------------------------------------------------------------------------------------
-
-  if (iproc==0) then
-   write(*,'(a)')'--------------------------------------------------------------------------------------------'
-   write(*,'(a)')'Starting a Poisson-Bolzmann run'
-  end if
-  
-  call f_zero(x)
-  call f_zero(r_PB)
-  call f_zero(x_PB)
-  call f_memcpy(src=b,dest=r)
-
-  beta=1.d0
-  ratio=1.d0
-
-  do i_PB=1,max_iter_PB ! Poisson-Boltzmann loop.
-
-   if (iproc==0) then
-    write(*,'(a)')'--------------------------------------------------------------------------------------------!'
-    write(*,*)'Starting Poisson-Boltzmann iteration ',i_PB
-   end if
-
-
-  if (iproc==0) then
-   write(*,'(a)')'--------------------------------------------------------------------------------------------'
-   write(*,'(a)')'Starting Preconditioned Conjugate Gradient'
-  end if
-
-  normb=0.d0
-  isp=1
-  do i3=1,n03
-   do i2=1,n02
-    do i1=1,n01
-     normb=normb+b(i1,i2,i3,isp)*b(i1,i2,i3,isp)
-     !!lv(i1,i2,i3,isp) = b(i1,i2,i3,isp)/dsqrt(eps(i1,i2,i3))
-    end do
-   end do
-  end do
-!!  normb=dsqrt(normb)
-  normb=sqrt(normb/rpoints)
-
-!  call f_memcpy(src=b,dest=r)
-!  call f_zero(x)
-  call f_zero(q)
-  call f_zero(p)
-  beta=1.d0
-  ratio=1.d0
-  normr=normb
-
-  do i3=1,n03
-     do i2=1,n02
-        do i1=1,n01
-           !lv(i1,i2,i3,isp) = r(i1,i2,i3,isp)/dsqrt(eps(i1,i2,i3))
-           !lv(i1,i2,i3,isp) = pkernel%oneoeps(i1,i2,i3)*r(i1,i2,i3,isp)
-           lv(i1,i2,i3,isp) = oneosqrteps(i1,i2,i3)*r(i1,i2,i3,isp)
-        end do
-     end do
-  end do
-
-  if (i_PB.eq.1) then
-   errorvar=1.0d-6
-   errorvar=max(error,errorvar)
-  else if (i_PB.eq.2) then
-   errorvar=1.0d-8
-   errorvar=max(error,errorvar)
-  else
-   errorvar=error
-  end if
-  if (iproc ==0) then
-   call yaml_map('errorvar',errorvar)
-  end if
-
-  do i=1,max_iter
-
-   if (normr.lt.errorvar) exit
-   if (normr.gt.max_ratioex) exit
-
-   if (iproc==0) then
-    write(*,'(a)')'--------------------------------------------------------------------------------------------!'
-    write(*,*)'Starting PCG iteration ',i
-   end if
-
-!  Apply the Preconditioner
-
-   if (iproc ==0) then
-    call yaml_sequence(advance='no')
-   end if
-   call H_potential('G',pkernel,lv,pot_ion,ehartree,offset,.false.)
-
-   beta0 = beta
-   beta=0.d0
-   isp=1
-   do i3=1,n03
-    do i2=1,n02
-     do i1=1,n01
-        !z(i1,i2,i3,isp) = lv(i1,i2,i3,isp)/dsqrt(eps(i1,i2,i3))
-        !z(i1,i2,i3,isp) = lv(i1,i2,i3,isp)*pkernel%oneoeps(i1,i2,i3)
-        z(i1,i2,i3,isp) = lv(i1,i2,i3,isp)*oneosqrteps(i1,i2,i3)
-        beta=beta+r(i1,i2,i3,isp)*z(i1,i2,i3,isp)
-! Apply the Generalized Laplace operator nabla(eps*nabla) to the potential correction
-      !q(i1,i2,i3,isp)=r(i1,i2,i3,isp)+z(i1,i2,i3,isp)*corr(i1,i2,i3,isp)
-     end do
-    end do
-   end do
-
-
-   k=0.d0
-   isp=1
-
-  do i3=1,n03
-    do i2=1,n02
-     do i1=1,n01
-        zeta=z(i1,i2,i3,isp)
-        !epsc=corr(i1,i2,i3,isp)
-        !epsc=pkernel%corr(i1,i2,i3)
-        epsc=corr3(i1,i2,i3)
-        pval=p(i1,i2,i3,isp)
-        qval=q(i1,i2,i3,isp)
-        rval=r(i1,i2,i3,isp)
-        pval = zeta+(beta/beta0)*pval
-        pbval=0.d0
-!        pbval=-switch*((eps(i1,i2,i3)-1.0d0)/(eps0-1.0d0))*PB_charge(zeta) ! Additional contribution to the Generalized Poisson operator
-!                                                                           ! for the Poisson-Boltzmann solution.
-!        pbval=switch*((eps(i1,i2,i3)-1.0d0)/(eps0-1.0d0))*dsinh(multp*zeta)
-!        pbval=switch*((eps(i1,i2,i3)-1.0d0)/(eps0-1.0d0))*multp*zeta*dcosh(multp*x(i1,i2,i3,isp))
-!        pbval=switch*((eps(i1,i2,i3)-1.0d0)/(eps0-1.0d0))*dtanh(multp*zeta)
-!        pbval=switch*((eps(i1,i2,i3)-1.0d0)/(eps0-1.0d0))*multp*zeta
-!        pbval=switch*((eps(i1,i2,i3)-1.0d0)/(eps0-1.0d0))*multp*(zeta**2)
-        qval = zeta*epsc+rval+pbval+(beta/beta0)*qval
-        k = k + pval*qval
-        p(i1,i2,i3,isp) = pval
-        q(i1,i2,i3,isp) = qval
-        !p(i1,i2,i3,isp) = z(i1,i2,i3,isp)+(beta/beta0)*p(i1,i2,i3,isp)
-        !q(i1,i2,i3,isp) = q(i1,i2,i3,isp)+(beta/beta0)*qold(i1,i2,i3,isp)
-        !qold(i1,i2,i3,isp)=q(i1,i2,i3,isp)
-        !k=k+p(i1,i2,i3,isp)*q(i1,i2,i3,isp)
-     end do
-    end do
-   end do
-
-   alpha = beta/k
-   !write(*,*)alpha
-
-   normr=0.d0
-   isp=1
-   do i3=1,n03
-    do i2=1,n02
-     do i1=1,n01
-      x(i1,i2,i3,isp) = x(i1,i2,i3,isp) + alpha*p(i1,i2,i3,isp)
-      r(i1,i2,i3,isp) = r(i1,i2,i3,isp) - alpha*q(i1,i2,i3,isp)
-      normr=normr+r(i1,i2,i3,isp)*r(i1,i2,i3,isp)
-      !lv(i1,i2,i3,isp) = r(i1,i2,i3,isp)/dsqrt(eps(i1,i2,i3))
-      !lv(i1,i2,i3,isp) = r(i1,i2,i3,isp)*pkernel%oneoeps(i1,i2,i3)
-      lv(i1,i2,i3,isp) = r(i1,i2,i3,isp)*oneosqrteps(i1,i2,i3)
-      !x_check(i1,i2,i3,isp) = x_PB(i1,i2,i3,isp) + x(i1,i2,i3,isp)
-!      x_check(i1,i2,i3,isp) = x(i1,i2,i3,isp)
-     end do
-    end do
-   end do
-!   normr=dsqrt(normr)
-   normr=sqrt(normr/rpoints)
-
-   ratio=normr/normb
-   if (iproc ==0) then
-!   write(18,'(1x,I8,3(1x,e14.7))')i,normr,ratio,beta
-   !write(*,'(1x,I8,2(1x,e14.7))')i,ratio,beta
-   call EPS_iter_output_LG(i,normb,normr,ratio,alpha,beta)
-!   call writeroutine(n01,n02,n03,nspden,r,i)
-   call writeroutinePot(n01,n02,n03,nspden,x,i,potential)
-   end if
-
-  end do ! PCG loop
-
-   rhores2=0.d0
-   isp=1
-   do i3=1,n03
-    do i2=1,n02
-     do i1=1,n01
-      zeta=x(i1,i2,i3,isp)
-      res=switch*((eps(i1,i2,i3)-1.0d0)/(eps0-1.0d0))*PB_charge(zeta) ! Additional contribution to the Generalized Poisson operator
-                                                                      ! for the Poisson-Boltzmann equation.
-      rho=r_PB(i1,i2,i3,isp)
-      res=res-rho
-      res=eta*res
-      rhores2=rhores2+res*res
-      r_PB(i1,i2,i3,isp)=res+rho
-!      x_PB(i1,i2,i3,isp) = x_PB(i1,i2,i3,isp) + x(i1,i2,i3,isp)
-!      r(i1,i2,i3,isp) = b(i1,i2,i3,isp) + r_PB(i1,i2,i3,isp)
-      r(i1,i2,i3,isp) = r(i1,i2,i3,isp) + r_PB(i1,i2,i3,isp) - rho
-     end do
-    end do
-   end do
-
-  normrPB=sqrt(rhores2/rpoints)
-
-   if (iproc==0) then
-    write(*,'(a)')'--------------------------------------------------------------------------------------------!'
-    write(*,*)'End Poisson-Boltzmann iteration ',i_PB
-   end if
-
-  if (iproc ==0) then
-   call yaml_map('iter PB',i_PB)
-   call yaml_map('normrPB',normrPB)
-   call yaml_map('rhores2',rhores2)
-   write(18,'(1x,I8,3(1x,e14.7))')i_PB,normrPB,rhores2
-   call writeroutinePot(n01,n02,n03,nspden,x,i_PB,potential)
-  end if
-
-   if (normrPB.lt.tauPB) exit
-   if (normrPB.gt.max_ratioex_PB) exit
-
- end do ! Poisson-Boltzmann loop
-
-   isp=1
-   do i3=1,n03
-    do i2=1,n02
-     do i1=1,n01
-      b(i1,i2,i3,isp) = x(i1,i2,i3,isp)
-     end do
-    end do
-   end do
-
-  call yaml_sequence_close()
-   !write(*,*)
-   !write(*,'(1x,a,1x,I8)')'PCG iterations =',i-1
-   !write(*,'(1x,a,1x,e14.7)')'PCG error =',ratio
-   !write(*,*)
-   !write(*,*)'Max abs difference between analytic potential and the computed one'
-!  if (iproc==0) then
-!   call writeroutinePot(n01,n02,n03,nspden,b,i-1,potential)
-!   write(*,*)
-!  end if
-
-  close(unit=18)
-  close(unit=38)
-
-  if (iproc==0) then
-   write(*,'(a)')'Termination of Preconditioned Conjugate Gradient'
-   write(*,'(a)')'--------------------------------------------------------------------------------------------'
-  end if
-
-  call f_free(x)
-  call f_free(r)
-  call f_free(z)
-  call f_free(p)
-  call f_free(q)
-  call f_free(qold)
-  call f_free(lv)
-  call f_free(corr)
-  call f_free(deps)
-  call f_free(ddeps)
-  call f_free(de2)
-  call f_free(r_PB)
-  call f_free(x_PB)
-  call f_free(x_check)
-
-end subroutine Poisson_Boltzmann_improved2
-
 subroutine EPS_iter_output_LG(iter,normb,normr,ratio,alpha,beta)
   !use module_defs, only: dp
   use yaml_output
@@ -2440,7 +2075,7 @@
 
   pi = 4.d0*datan(1.d0)
 
-   call fssnord3DmatNabla("S",n01,n02,n03,nspden,hx,hy,hz,x,dx,nord,acell)
+   call fssnord3DmatNabla(n01,n02,n03,nspden,hx,hy,hz,x,dx,nord,acell)
 
      flux=0.d0
       isp=1
@@ -2578,7 +2213,7 @@
   dx=f_malloc([n01,n02,n03,nspden,3],id='dx')
   deps=f_malloc([n01,n02,n03,3],id='deps')
 
-  call fssnord3DmatNabla("F",n01,n02,n03,nspden,hx,hy,hz,x,dx,nord,acell)
+  call fssnord3DmatNabla(n01,n02,n03,nspden,hx,hy,hz,x,dx,nord,acell)
 
       isp=1
       do i3=1,n03
@@ -2591,7 +2226,7 @@
        end do
       end do
 
-   call fssnord3DmatDiv("F",n01,n02,n03,nspden,hx,hy,hz,dx,y,nord,acell)
+   call fssnord3DmatDiv(n01,n02,n03,nspden,hx,hy,hz,dx,y,nord,acell)
 
      i3=1!n03/2
      do i2=1,n02
@@ -4453,8 +4088,8 @@
     call SetEledens(n01,n02,n03,nspden,nord,acell,a_gauss,hx,hy,hz,SetEps,edens,nabla_edens,ddt_edens)
    else if (SetEps.eq.3) then
     edens(:,:,:,:) = rhoele(:,:,:,:)
-    call fssnord3DmatNabla(geocode,n01,n02,n03,nspden,hx,hy,hz,edens,nabla_edens,nord,acell)
-    call fssnord3DmatDiv(geocode,n01,n02,n03,nspden,hx,hy,hz,nabla_edens,ddt_edens,nord,acell)
+    call fssnord3DmatNabla(n01,n02,n03,nspden,hx,hy,hz,edens,nabla_edens,nord,acell)
+    call fssnord3DmatDiv(n01,n02,n03,nspden,hx,hy,hz,nabla_edens,ddt_edens,nord,acell)
    end if
 
 !   r2=(rad_cav/0.52917721092d0)**2
@@ -4933,8 +4568,7 @@
   real(kind=8), dimension(ndims(1),ndims(2),ndims(3)), intent(out) :: eps !< dielectric function
   real(kind=8), dimension(3,ndims(1),ndims(2),ndims(3)), intent(out) :: dlogeps !< dlogeps
   real(kind=8), dimension(ndims(1),ndims(2),ndims(3)), intent(out) :: oneoeps !< inverse of epsilon. Needed for PI method.
-  !> inverse square root of epsilon. Needed for PCG method.
-  real(kind=8), dimension(ndims(1),ndims(2),ndims(3)), intent(out) :: oneosqrteps 
+  real(kind=8), dimension(ndims(1),ndims(2),ndims(3)), intent(out) :: oneosqrteps !< inverse square root of epsilon. Needed for PCG method.
   real(kind=8), dimension(ndims(1),ndims(2),ndims(3)), intent(out) :: corr !< correction term of the Generalized Laplacian.
   !local variables
   integer :: i,i1,i2,i3,iat

=== modified file 'PSolver/tests/PS_Check.f90'
--- PSolver/tests/PS_Check.f90	2015-06-18 13:40:44 +0000
+++ PSolver/tests/PS_Check.f90	2015-04-03 08:24:34 +0000
@@ -20,7 +20,6 @@
   implicit none
   !Length of the box
   character(len=*), parameter :: subname='PS_Check'
-  logical :: usegpu
   real(kind=8), parameter :: a_gauss = 1.0d0,a2 = a_gauss**2
   real(kind=8), parameter :: acell = 10.d0
   character(len=50) :: chain
@@ -35,7 +34,7 @@
   integer :: ncount0,ncount1,ncount_rate,ncount_max
   integer :: n01,n02,n03,itype_scf!,i_all,i_stat
   integer :: iproc,nproc,namelen,ierr,ispden
-  integer :: n_cell,igpu
+  integer :: n_cell
   integer, dimension(3) :: nxyz
   integer, dimension(3) :: ndims
   real(wp), dimension(:,:,:,:), pointer :: rhocore
@@ -86,15 +85,12 @@
 
   nxyz=options//'ndim'
   geocode=options//'geocode'
-  usegpu = options // 'accel'
-
 
   call dict_free(options)
   n01=nxyz(1)
   n02=nxyz(2)
   n03=nxyz(3)
-  igpu=0
-  if (usegpu) igpu=1
+
   !print *,iproc,n01,n02,n03
 
   !Step size
@@ -124,7 +120,7 @@
   ndims=(/n01,n02,n03/)
   hgrids=(/hx,hy,hz/)
 
-  pkernel=pkernel_init(.true.,iproc,nproc,igpu,&
+  pkernel=pkernel_init(.true.,iproc,nproc,0,&
        geocode,ndims,hgrids,itype_scf,taskgroup_size=nproc/2)
   call pkernel_set(pkernel,verbose=.true.)
 
@@ -1000,11 +996,6 @@
        'Allowed values' .is. &
        dict_new("PI" .is. 'Polarization iteration Method',&
                "PCG" .is. 'Preconditioned Conjugate Gradient')))
-  call yaml_cl_parse_option(parser,'accel','No',&
-       'GPU Acceleration','a',&
-       dict_new('Usage' .is. &
-       'Boolean, set the GPU acceleration'))
-
 
 end subroutine PS_Check_options
 

=== modified file 'configure.ac'
--- configure.ac	2015-06-16 19:23:59 +0000
+++ configure.ac	2015-06-12 13:39:14 +0000
@@ -1059,10 +1059,9 @@
 dnl Test S_GPU library.
 ac_build_libsgpu="no"
 ac_use_libsgpu="no"
-dnl AC_ARG_ENABLE(internal-libsgpu, AS_HELP_STRING([--disable-internal-libsgpu], [Do not build and link with internal S_GPU library (default = yes).]), ac_internal_sgpu=$enableval, ac_internal_sgpu="no")
-ac_internal_sgpu="no"
+AC_ARG_ENABLE(internal-libsgpu, AS_HELP_STRING([--disable-internal-libsgpu], [Do not build and link with internal S_GPU library (default = yes).]), ac_internal_sgpu=$enableval, ac_internal_sgpu="no")
 ac_build_libsgpu=$ac_internal_sgpu
-if test x"$ac_use_cuda_gpu" = "xnotdothat" ; then
+if test x"$ac_use_cuda_gpu" = "xyes" ; then
   dnl Test S_GPU library.
   ac_internal_sgpu="yes"
   AC_ARG_WITH(libsgpu-path, AS_HELP_STRING([--with-libsgpu-path], [Give the path for an external S_GPU library, lib and module files (default = None).]),
@@ -1213,9 +1212,9 @@
 if test x"$ac_build_libxc" != x"skip" ; then
    AC_CONFIG_SUBDIRS([libxc-2.0.x])
 fi
-dnl if test x"$ac_build_libsgpu" != x"skip" ; then
-dnl  AC_CONFIG_SUBDIRS([S_GPU])
-dnl fi
+if test x"$ac_build_libsgpu" != x"skip" ; then
+   AC_CONFIG_SUBDIRS([S_GPU])
+fi
 if test x"$ac_build_libyaml" != x"skip" ; then
    AC_CONFIG_SUBDIRS([yaml-0.1.4])
 fi

=== modified file 'flib/src/f_input_file.f90'
--- flib/src/f_input_file.f90	2015-06-16 19:23:59 +0000
+++ flib/src/f_input_file.f90	2015-05-19 20:01:04 +0000
@@ -117,7 +117,6 @@
              iter => dict_iter(dict_tmp2)
              do while(associated(iter))
                 call dict_update(dict,imports//dict_value(iter))
-                if (COMMENT .in. dict) call dict_remove(dict,COMMENT)
                 iter => dict_next(iter)
              end do
           else if (dict_size(dict_tmp2) > 0 ) then
@@ -131,6 +130,7 @@
           call dict_free(dict_tmp)
        end if
     end if
+    
     localcheck=.true.
     dict_tmp => dict_iter(inputdef)
     do while (associated(dict_tmp))

=== modified file 'flib/src/f_precisions.f90'
--- flib/src/f_precisions.f90	2015-06-16 19:23:59 +0000
+++ flib/src/f_precisions.f90	2015-05-19 20:01:04 +0000
@@ -18,7 +18,7 @@
 
   !for integers to be verified
   integer, parameter :: f_short=selected_int_kind(4)
-  integer, parameter :: f_integer=selected_int_kind(8)
+  integer, parameter :: f_int=selected_int_kind(8)
   integer, parameter :: f_long=selected_int_kind(16)
 
   !logicals to be done also, and tested against bits and bytes with f_loc

=== modified file 'flib/src/f_utils.f90'
--- flib/src/f_utils.f90	2015-06-16 19:23:59 +0000
+++ flib/src/f_utils.f90	2015-05-19 20:01:04 +0000
@@ -232,17 +232,17 @@
 
   !>create a directory from CWD path
   subroutine f_mkdir(dir,path)
-    use f_precisions, only: f_integer
+    use f_precisions, only: f_int
     implicit none
     character(len=*), intent(in) :: dir !<directory to be created
     character(len=*), intent(out) :: path !<path of the created directory (trailing slash added)
     !local variables
     integer :: ierr
-    integer(f_integer) :: lin,lout
+    integer(f_int) :: lin,lout
 
     call f_zero(path)
-    lin=int(len_trim(dir),f_integer)
-    lout=int(len(path),f_integer)
+    lin=int(len_trim(dir),f_int)
+    lout=int(len(path),f_int)
 
     call getdir(dir,lin,path,lout,ierr)
     if (ierr /= 0 .and. ierr /= 1) then

=== modified file 'flib/tests/utls.f90'
--- flib/tests/utls.f90	2015-06-18 12:24:41 +0000
+++ flib/tests/utls.f90	2015-05-19 20:01:04 +0000
@@ -28,7 +28,7 @@
   complex(f_double), dimension(3) :: c2
   complex(f_quadruple), dimension(3) :: c4
   integer(f_short), dimension(3) :: is
-  integer(f_integer), dimension(3) :: i4
+  integer(f_int), dimension(3) :: i4
   integer(f_long), dimension(3) :: il
   logical(f_byte), dimension(3) :: lb
   logical, dimension(3) :: l

=== modified file 'src/CUDA/Makefile.am'
--- src/CUDA/Makefile.am	2015-06-18 13:40:44 +0000
+++ src/CUDA/Makefile.am	2013-05-22 14:26:18 +0000
@@ -10,9 +10,10 @@
 	kinetic.cu kinetic.h \
 	compress.cu
 if USE_CUDA_GPU
-sources = \
+sources = binding_s_gpu.c \
 	commonDef.cpp commonDef.h \
 	cudafct.cu \
+	locham.cu \
 	kernels_anasyn.hcu \
 	kernels_locpot.hcu \
 	kernels_kinetic.hcu \
@@ -21,11 +22,9 @@
 	structDef_anasyn.h \
 	structDef_locpot.h \
 	structDef_kinetic.h \
+	check_cuda.h \
 	read_conf_exception.h \
 	cpp_utils.h
-
-#binding_s_gpu.c check_cuda.h locham.cu
-
 else
 sources =
 endif
@@ -38,7 +37,7 @@
 AM_CPPFLAGS = -I. -I$(top_builddir) -I@CUDA_PATH@/include/ @LIBSGPU_INCLUDE@
 
 NVCC = @NVCC@
-NVCC_FLAGS = -arch sm_20 @NVCC_FLAGS@ 
+NVCC_FLAGS = -arch sm_13 @NVCC_FLAGS@ 
 SUFFIXES = .cu
 
 CLEANFILES = fort.1 fort.98 *linkinfo

=== modified file 'src/cluster.f90'
--- src/cluster.f90	2015-08-04 08:04:07 +0000
+++ src/cluster.f90	2015-06-14 16:52:09 +0000
@@ -1592,7 +1592,6 @@
            end if
 
            opt%iter = opt%iter + 1
-!        if (opt%iter == 2) stop
         end do wfn_loop
 
 
@@ -1927,18 +1926,6 @@
 
      call plot_density(iproc,nproc,trim(dir_output)//'electronic_density' // gridformat,&
           atoms,rxyz,denspot%dpbox,denspot%dpbox%nrhodim,denspot%rho_work)
-!---------------------------------------------------
-! giuseppe fisicaro dilectric cavity
-     if (iproc == 0) call yaml_map('Writing polarization charge in file','polarization_charge'//gridformat)
-
-     call plot_density(iproc,nproc,trim(dir_output)//'polarization_charge' // gridformat,&
-          atoms,rxyz,denspot%dpbox,denspot%dpbox%nrhodim,denspot%pkernel%pol_charge)
-
-     if (iproc == 0) call yaml_map('Writing dielectric cavity in file','dielectric_cavity'//gridformat)
-
-     call plot_density(iproc,nproc,trim(dir_output)//'dielectric_cavity' // gridformat,&
-          atoms,rxyz,denspot%dpbox,denspot%dpbox%nrhodim,denspot%pkernel%cavity)
-!---------------------------------------------------
 
      if (associated(denspot%rho_C) .and. denspot%dpbox%n3d>0) then
         if (iproc == 0) call yaml_map('Writing core density in file','core_density'//gridformat)

=== modified file 'src/convolutions/convolut_common_interface_ocl.f90'
--- src/convolutions/convolut_common_interface_ocl.f90	2015-06-16 19:23:59 +0000
+++ src/convolutions/convolut_common_interface_ocl.f90	2014-07-13 22:09:09 +0000
@@ -20,7 +20,6 @@
 
 subroutine init_acceleration_OCL(matacc,GPU)
   use module_base
-  use module_input_keys, only: material_acceleration
   use module_types
   implicit none
   type(material_acceleration), intent(in) :: matacc

=== modified file 'src/init/ionicpot.f90'
--- src/init/ionicpot.f90	2015-08-04 08:04:07 +0000
+++ src/init/ionicpot.f90	2015-06-18 15:41:25 +0000
@@ -624,9 +624,6 @@
 
   !buffers associated to the geocode
   !conditions for periodicity in the three directions
-  perx=.false.
-  pery=.false.
-  perz=.false.
   perx=(geocode /= 'F')
   pery=(geocode == 'P')
   perz=(geocode /= 'F')
@@ -732,16 +729,16 @@
    rxyz(1:3,1:nat)=rxyztot(1:3,1:nat)
    radii(1:nat)=radiitot(1:nat)
 
-   if (bigdft_mpi%iproc==0) then
+!   if (bigdft_mpi%iproc==0) then
 !    write(*,*)plandist
 !    write(*,'(1x,a,1x,e14.7,1x,a,1x,i4)')'Value min =',valuemin,'at bc side',imin
-    call yaml_map('nat for pbc',nat)
+!    call yaml_map('nat',nat)
 !    do iat=1,nat
 !     call yaml_map('atom',iat)
 !     call yaml_map('radii',radii(iat))
 !     call yaml_map('rxyz',rxyz(:,iat))
 !    end do
-   end if
+!   end if
 
 !------------------------------------------------------------------------------------------------------
 ! Starting the cavity building for rxyztot atoms=real+image atoms (total natcurr) for periodic
@@ -788,53 +785,53 @@
      oneoeps(i1,i2,i3)=1.d0/eps(i1,i2,i3)
      oneosqrteps(i1,i2,i3)=1.d0/dsqrt(eps(i1,i2,i3))
 
-!     do i=1,3
-!      deps(i)=0.d0
-!      do jat=0,nat-1
-!       curr=dep(i,jat+1)
-!       do iat=1,nat-1
-!        curr=curr*ep(modulo(iat+jat,nat)+1)
-!       end do
-!        deps(i) = deps(i) + curr
-!      end do
-!      deps(i) = deps(i)*(epsilon0-1.d0)
-!     end do
-!
-!     d12=0.d0
-!     do i=1,3
-!      dlogeps(i,i1,i2,i3)=deps(i)/eps(i1,i2,i3)
-!      d12 = d12 + deps(i)**2
-!     end do
-!
-!     IntSur = IntSur + dsqrt(d12)
-!
-!     dd=0.d0
-!     do jat=1,nat
-!      curr=ddep(jat)
-!      do iat=1,nat-1
-!       curr=curr*ep(modulo(iat+jat-1,nat)+1)
-!      end do
-!      dd = dd + curr
-!     end do
-!
-!      do i=1,3
-!       do iat=1,nat-1
-!        do jat=iat+1,nat
-!         curr=dep(i,iat)*dep(i,jat)
-!         do ii=1,nat
-!          if ((ii.eq.iat).or.(ii.eq.jat)) then
-!          else
-!           curr=curr*ep(ii)
-!          end if
-!         end do
-!         curr=curr*2.d0
-!         dd = dd + curr
-!        end do
-!       end do
-!      end do
-
-!     dd=dd*(epsilon0-1.d0)
-!     corr(i1,i2,i3)=(-0.125d0/pi)*(0.5d0*d12/eps(i1,i2,i3)-dd)
+     do i=1,3
+      deps(i)=0.d0
+      do jat=0,nat-1
+       curr=dep(i,jat+1)
+       do iat=1,nat-1
+        curr=curr*ep(modulo(iat+jat,nat)+1)
+       end do
+        deps(i) = deps(i) + curr
+      end do
+      deps(i) = deps(i)*(epsilon0-1.d0)
+     end do
+
+     d12=0.d0
+     do i=1,3
+      dlogeps(i,i1,i2,i3)=deps(i)/eps(i1,i2,i3)
+      d12 = d12 + deps(i)**2
+     end do
+
+     IntSur = IntSur + dsqrt(d12)
+
+     dd=0.d0
+     do jat=1,nat
+      curr=ddep(jat)
+      do iat=1,nat-1
+       curr=curr*ep(modulo(iat+jat-1,nat)+1)
+      end do
+      dd = dd + curr
+     end do
+
+      do i=1,3
+       do iat=1,nat-1
+        do jat=iat+1,nat
+         curr=dep(i,iat)*dep(i,jat)
+         do ii=1,nat
+          if ((ii.eq.iat).or.(ii.eq.jat)) then
+          else
+           curr=curr*ep(ii)
+          end if
+         end do
+         curr=curr*2.d0
+         dd = dd + curr
+        end do
+       end do
+      end do
+
+     dd=dd*(epsilon0-1.d0)
+     corr(i1,i2,i3)=(-0.125d0/pi)*(0.5d0*d12/eps(i1,i2,i3)-dd)
 
     end do
    end do

=== modified file 'src/init/sysprop.f90'
--- src/init/sysprop.f90	2015-08-04 08:04:07 +0000
+++ src/init/sysprop.f90	2015-06-16 14:55:53 +0000
@@ -850,7 +850,7 @@
   !local variables
   real(gp), parameter :: epsilon0=78.36d0 ! Constant dielectric permittivity of water.
   real(gp), parameter :: fact=1.2d0 ! Multiplying factor to enlarge the rigid cavity.
-  integer :: i1,i2,i3,unt,i,i3s,i23
+  integer :: i1,i2,i3,unt,i
   real(gp) :: delta,IntSur,IntVol,noeleene,Cavene,Repene,Disene
   type(atoms_iterator) :: it
   real(gp), dimension(:), allocatable :: radii,radii_nofact
@@ -882,7 +882,7 @@
 
 !  delta=4.0*maxval(pkernel%hgrids)
   delta=2.0d0
-!  if(bigdft_mpi%iproc==0) call yaml_map('Delta cavity',delta)
+  if(bigdft_mpi%iproc==0) call yaml_map('Delta cavity',delta)
   delta=delta*0.25d0 ! Divided by 4 because both rigid cavities are 4*delta widespread 
 
   do i=1,atoms%astruct%nat
@@ -901,41 +901,39 @@
     radii(i)=1.8d0
    case('Cl')
     radii(i)=1.8d0
-   case('Ti')
-    radii(i)=1.8d0
    case default
     call f_err_throw('For rigid cavity a radius should be fixed for each atom type')
    end select
-!   if (bigdft_mpi%iproc==0) call yaml_map('Atomic type',atoms%astruct%atomnames(atoms%astruct%iatype(i)))
+   if (bigdft_mpi%iproc==0) call yaml_map('Atomic type',atoms%astruct%atomnames(atoms%astruct%iatype(i)))
    radii_nofact(i) = radii(i)/Bohr_Ang +1.05d0*delta
    radii(i) = fact*radii(i)/Bohr_Ang + 1.22d0*delta
   end do
-!  if (bigdft_mpi%iproc==0) call yaml_map('Covalent radii',radii)
+  if (bigdft_mpi%iproc==0) call yaml_map('Covalent radii',radii)
 
 !--------------------------------------------
 
 ! Calculation of non-electrostatic contribution. Use of raddi without fact
 ! multiplication.
-!  call epsilon_rigid_cavity_error_multiatoms_bc(atoms%astruct%geocode,pkernel%ndims,pkernel%hgrids,&
-!       atoms%astruct%nat,rxyz,radii_nofact,&
-!       epsilon0,delta,eps,dlogeps,oneoeps,oneosqrteps,corr,IntSur,IntVol)
+  call epsilon_rigid_cavity_error_multiatoms_bc(atoms%astruct%geocode,pkernel%ndims,pkernel%hgrids,&
+       atoms%astruct%nat,rxyz,radii_nofact,&
+       epsilon0,delta,eps,dlogeps,oneoeps,oneosqrteps,corr,IntSur,IntVol)
 !  call epsilon_rigid_cavity_new_multiatoms(atoms%astruct%geocode,pkernel%ndims,pkernel%hgrids,atoms%astruct%nat,rxyz,radii_nofact,&
 !       epsilon0,delta,eps,dlogeps,oneoeps,oneosqrteps,corr,IntSur,IntVol)
 
-!  if (bigdft_mpi%iproc==0) then
-!     call yaml_map('Surface integral',IntSur)
-!     call yaml_map('Volume integral',IntVol)
-!  end if
-!  Cavene= 72.d-13*Bohr_Ang*IntSur/8.238722514d-8*627.509469d0
-!  Repene=-22.d-13*Bohr_Ang*IntSur/8.238722514d-8*627.509469d0
-!  Disene=-0.35d9*IntVol*2.942191219d-13*627.509469d0
-!  noeleene=Cavene+Repene+Disene
-!  if (bigdft_mpi%iproc==0) then
-!     call yaml_map('Cavity energy',Cavene)
-!     call yaml_map('Repulsion energy',Repene)
-!     call yaml_map('Dispersion energy',Disene)
-!     call yaml_map('Total non-electrostatic energy',noeleene)
-!  end if
+  if (bigdft_mpi%iproc==0) then
+     call yaml_map('Surface integral',IntSur)
+     call yaml_map('Volume integral',IntVol)
+  end if
+  Cavene= 72.d-13*Bohr_Ang*IntSur/8.238722514d-8*627.509469d0
+  Repene=-22.d-13*Bohr_Ang*IntSur/8.238722514d-8*627.509469d0
+  Disene=-0.35d9*IntVol*2.942191219d-13*627.509469d0
+  noeleene=Cavene+Repene+Disene
+  if (bigdft_mpi%iproc==0) then
+     call yaml_map('Cavity energy',Cavene)
+     call yaml_map('Repulsion energy',Repene)
+     call yaml_map('Dispersion energy',Disene)
+     call yaml_map('Total non-electrostatic energy',noeleene)
+  end if
 
 !--------------------------------------------
 
@@ -953,22 +951,9 @@
 !!$  corr=0.d0
 !!$  oneosqrteps=1.d0
 
-  !starting point in third direction
-  i3s=pkernel%grid%istart+1
-  i23=1
-  do i3=i3s,i3s+pkernel%grid%n3p-1!kernel%ndims(3)
-     do i2=1,pkernel%ndims(2)
-        do i1=1,pkernel%ndims(1)
-           pkernel%cavity(i1,i23)=eps(i1,i2,i3)
-        end do
-        i23=i23+1
-     end do
-  end do
-
   select case(trim(f_str(pkernel%method)))
   case('PCG')
-!   call pkernel_set_epsilon(pkernel,oneosqrteps=oneosqrteps,corr=corr)
-   call pkernel_set_epsilon(pkernel,eps=eps)
+   call pkernel_set_epsilon(pkernel,oneosqrteps=oneosqrteps,corr=corr)
   case('PI') 
    call pkernel_set_epsilon(pkernel,oneoeps=oneoeps,dlogeps=dlogeps)
   end select
@@ -1034,12 +1019,11 @@
 !  if(bigdft_mpi%iproc==0) call yaml_map('Delta cavity',delta)
 
   do i=1,atoms%astruct%nat
-   radii(i) = 1.5d0/Bohr_Ang
+   radii(i) = 0.5d0/Bohr_Ang
   end do
 !  if (bigdft_mpi%iproc==0) call yaml_map('Covalent radii',radii)
 
-  call epsinnersccs_rigid_cavity_error_multiatoms_bc(atoms%astruct%geocode,&
-       pkernel%ndims,pkernel%hgrids,atoms%astruct%nat,rxyz,radii,delta,eps)
+  call epsinnersccs_rigid_cavity_error_multiatoms_bc(atoms%astruct%geocode,pkernel%ndims,pkernel%hgrids,atoms%astruct%nat,rxyz,radii,delta,eps)
 
   n1=pkernel%ndims(1)
   n23=pkernel%ndims(2)*pkernel%grid%n3p
@@ -2588,3 +2572,5 @@
      tmb%c_obj    = 0
   end if
 END SUBROUTINE system_signaling
+
+

=== modified file 'src/initialization.f90'
--- src/initialization.f90	2015-06-16 19:23:59 +0000
+++ src/initialization.f90	2015-06-12 13:39:14 +0000
@@ -251,6 +251,9 @@
      end do
      
      call f_free_str(MPI_MAX_PROCESSOR_NAME,nodename)
+     !i_all=-product(shape(nodename))*kind(nodename)
+     !deallocate(nodename,stat=i_stat)
+     !call memocc(i_stat,i_all,'nodename',subname)
   end if
   call f_release_routine()
 END SUBROUTINE processor_id_per_node

=== modified file 'src/input_variables_definition.yaml'
--- src/input_variables_definition.yaml	2015-06-18 12:24:41 +0000
+++ src/input_variables_definition.yaml	2015-04-27 14:35:55 +0000
@@ -196,7 +196,7 @@
      default: 0.0
 #K points parameters
  kpt:
-   DESCRIPTION: K points XXXXXXX defined in the Brillouin zone for periodic system calculations
+   DESCRIPTION: K points defined in the Brillouin zone for periodic system calculations
    method:
      COMMENT: K-point sampling method
      EXCLUSIVE:
@@ -1364,7 +1364,7 @@
                     Must be at least as large as the kernel cutoff.
        RANGE: [2.0,1000]
        default: 14.0
---- #here starts the document of possible profiles, that have to be evoked with the 'import' keyword
+--- #here starts the document of possible input files
 linear_accurate:
   COMMENT: appropriate input parameters for a high accuracy linear scaling calculation
   DESCRIPTION: This profile should be chosen if highly accurate energy differences are required
@@ -1473,92 +1473,3 @@
     ixc: PBE
   geopt:
     method: FIRE
-mixing:
-  COMMENT: to be used for metallic systems
-  dft:
-   gnrm_cv: 1.e-6
-   nrepmax: 1
-   itermax: 3
-   ncong: 5
-   idsx: 0
-  mix:
-   iscf: 17
-   itrpmax: 200
-   rpnrm_cv: 1.E-12
-   norbsempty: 120
-   tel: 0.01
-   alphamix: 0.8
-   alphadiis: 1.d0
-linear:
- COMMENT: linear parameters sufficient for PDoS, charge analysis, MD
- dft:
-   gnrm_cv: accurate
-   itermax: 50
-   nrepmax: 10
-   ncong: 5
-   idsx: 6
-   disablesym: Yes
-   inputpsiid: linear
- perf:
-   ef_interpol_chargediff: 1.0
-   check_sumrho: 1
-   check_overlap: 1
-   experimental_mode: Yes
-   calculate_KS_residue: No
-   method_updatekernel: 2
-   purification_quickreturn: Yes
-   check_matrix_compression: No
-   correction_co_contra: Yes
-   store_index: No
-   mixing_after_inputguess: 1
-   kappa_conv: 0.1
-   FOE_restart: 1
-   hamapp_radius_incr: 6
- lin_general:
-   hybrid: Yes
-   nit: 50
-   taylor_order: 1020
-   max_inversion_error: 5.0e-8
-   rpnrm_cv: 1.0e-11
-   output_mat: 1
-   output_coeff: 1
- lin_basis:
-   nit: 8
-   idsx: 8
-   gnrm_cv: 2.0e-3
-   deltae_cv: 1.0e-4
-   min_gnrm_for_dynamic: 4.0e-3
-   alpha_diis: 0.5
-   alpha_sd: 0.5
-   nstep_prec: 6
-   fix_basis: 1.0e-12
-   correction_orthoconstraint: 0
-   gnrm_ig: 1.e-1
- lin_kernel:
-   nstep: 10
-   nit: 6
-   idsx_coeff: [6, 0]
-   idsx: 6
-   alphamix: 0.1
-   linear_method: FOE
-   eval_range_foe: [-1.0, 1.0]
-   fscale_foe: 5.0E-002
- lin_basis_params:
-   ao_confinement: -1.0
-   confinement: -1.0
-   rloc_kernel: 9.0
-   rloc_kernel_foe: 10.5
-   H:  {nbasis: 1, rloc: 4.5}
-   C:  {nbasis: 4, rloc: 5.0}
-   N:  {nbasis: 4, rloc: 5.0}
-   O:  {nbasis: 4, rloc: 5.0}
-   P:  {nbasis: 4, rloc: 5.5}
-   Cl: {nbasis: 4, rloc: 5.5}
-   K:  {nbasis: 1, rloc: 7.0}
-md:
-  COMMENT: Molecular dynamics Input file for H2O molecules
-  geopt:
-    method: AB6MD
-    ionmov: 8
-    dtion: 20.0
-    noseinert: 30.0
\ No newline at end of file

=== modified file 'src/mhgps_files/module_minimizers.f90'
--- src/mhgps_files/module_minimizers.f90	2015-06-16 19:23:59 +0000
+++ src/mhgps_files/module_minimizers.f90	2015-06-10 20:17:38 +0000
@@ -595,7 +595,7 @@
     use module_energyandforces
     use module_sqn
     use bigdft_run, only: run_objects, state_properties
-    use module_mhgps_state, only: mhgps_state
+    use module_mhgps_state
     implicit none
     !parameter
     type(mhgps_state), intent(inout) :: mhgpsst

=== modified file 'src/modules/Makefile.am'
--- src/modules/Makefile.am	2015-06-18 13:40:44 +0000
+++ src/modules/Makefile.am	2015-06-10 20:17:38 +0000
@@ -244,7 +244,7 @@
 multipole_base.o: base.o
 fragment_base.o: public_keys.o
 ao_inguess.o: $(AO_INCLUDES) base.o public_keys.o
-input_dicts.o: $(top_builddir)/flib/src/dynamic_memory.o defs.o ao_inguess.o public_keys.o fragment_base.o input.o
+input_dicts.o: $(top_builddir)/flib/src/dynamic_memory.o defs.o ao_inguess.o public_keys.o fragment_base.o
 atoms_data.o: $(ATOMS_INCLUDES) ao_inguess.o internal_coordinates.o input_dicts.o
 input_keys.o: defs.o $(top_builddir)/flib/src/dynamic_memory.o base.o public_keys.o multipole_base.o atoms_data.o xc.o input.o fragment_base.o
 input.o: base.o public_keys.o fragment_base.o

=== modified file 'src/modules/bigdft_run.f90'
--- src/modules/bigdft_run.f90	2015-06-18 12:24:41 +0000
+++ src/modules/bigdft_run.f90	2015-06-12 13:39:14 +0000
@@ -1335,13 +1335,13 @@
     use public_enums
     use module_defs
     use dynamic_memory, only: f_memcpy
-    use yaml_strings, only: yaml_toa, operator(+)
+    use yaml_strings, only: yaml_toa
     use yaml_output
     use module_forces, only: clean_forces
     use module_morse_bulk
     use module_tersoff
     use module_BornMayerHugginsTosiFumi
-    use f_enums, enum_int => int
+    use f_enums, only: f_int => int
     implicit none
     !parameters
     type(run_objects), intent(inout) :: runObj
@@ -1451,7 +1451,7 @@
        if (bigdft_mpi%iproc==0) call yaml_map('BigDFT infocode',infocode)
     case default
        call f_err_throw('Following method for evaluation of '//&
-            'energies and forces is unknown: '+ yaml_toa(enum_int(runObj%run_mode)))
+            'energies and forces is unknown: '//trim(yaml_toa(f_int(runObj%run_mode))))
     end select
 !!         anoise=2.d-5
 !!         if (anoise.ne.0.d0) then

=== modified file 'src/modules/defs.f90'
--- src/modules/defs.f90	2015-06-16 19:23:59 +0000
+++ src/modules/defs.f90	2015-05-20 20:42:47 +0000
@@ -85,7 +85,7 @@
   !> Code constants.
   !real(gp), parameter :: UNINITIALISED = -123456789._gp
 
-  private :: f_double,f_simple,f_long,f_short,f_integer
+  private :: f_double,f_simple,f_long,f_short,f_int
 
   !interface for uninitialized variable
   interface UNINITIALIZED

=== modified file 'src/modules/input_dicts.f90'
--- src/modules/input_dicts.f90	2015-06-18 12:24:41 +0000
+++ src/modules/input_dicts.f90	2015-06-12 13:39:14 +0000
@@ -7,6 +7,7 @@
 !!    or http://www.gnu.org/copyleft/gpl.txt .
 !!    For the list of contributors, see ~/AUTHORS 
 
+
 !> Modules which contains all interfaces to parse input dictionary.
 module module_input_dicts
   use public_keys
@@ -252,7 +253,6 @@
     implicit none
     type(dictionary), pointer :: dict
     !local variables
-    character(len=*), parameter :: F_IMPORT_KEY='import'
     logical :: found,loginput
     type(dictionary), pointer :: valid_entries,valid_patterns
     type(dictionary), pointer :: iter,invalid_entries,iter2
@@ -280,8 +280,7 @@
          .item. LIN_BASIS_PARAMS,&
          .item. OCCUPATION,&
          .item. IG_OCCUPATION,&
-         .item. FRAG_VARIABLES,&
-         .item. F_IMPORT_KEY])
+         .item. FRAG_VARIABLES])
 
     !then the list of vaid patterns
     valid_patterns=>list_new(&
@@ -1752,8 +1751,7 @@
 
   !> Read the linear input variables
   subroutine read_lin_and_frag_from_text_format(iproc,dict,run_name)
-    use dictionaries, dict_set => set 
-    use module_defs, only: gp
+    use module_base
     use module_input
     use public_keys
     implicit none
@@ -2027,10 +2025,9 @@
 
   !> Read fragment input parameters
   subroutine fragment_input_variables_from_text_format(iproc,dump,filename,shouldexist,dict)
-    use module_defs, only: gp
+    use module_base
     use fragment_base
     use module_input
-    use dictionaries
     use yaml_output, only: yaml_toa,yaml_map
     implicit none
     logical, intent(in) :: shouldexist

=== modified file 'src/modules/input_keys.f90'
--- src/modules/input_keys.f90	2015-06-16 19:23:59 +0000
+++ src/modules/input_keys.f90	2015-06-14 16:52:09 +0000
@@ -28,7 +28,7 @@
 
   type(dictionary), pointer :: parameters=>null()
   type(dictionary), pointer :: parsed_parameters=>null()
-  type(dictionary), pointer :: profiles=>null()
+
 
 
  character(len = 12), dimension(0:2), parameter, public :: OUTPUT_DENSPOT_names = &
@@ -505,7 +505,6 @@
     call yaml_parse_from_char_array(parsed_parameters,params)
     !there is only one document in the input variables specifications
     parameters=>parsed_parameters//0
-    profiles => parsed_parameters//1
     call f_free_str(1,params)
 
     !call yaml_dict_dump(parameters, comment_key = COMMENT)
@@ -523,7 +522,6 @@
     if (associated(parsed_parameters)) then
        call dict_free(parsed_parameters)
        nullify(parameters)
-       nullify(profiles)
     else
        call dict_free(parameters)
     end if
@@ -852,6 +850,7 @@
   subroutine check_for_data_writing_directory(iproc,in)
     use yaml_output
     use module_defs, only: bigdft_mpi
+    use f_precisions, only: f_int
     use f_utils, only: f_zero,f_mkdir
     use wrapper_MPI, only: mpibcast
     use yaml_strings, only: f_strcpy
@@ -911,7 +910,6 @@
     use f_input_file
     use public_keys
     use yaml_strings, only: operator(.eqv.)
-    use yaml_output
     !use yaml_output
     implicit none
     type(dictionary), pointer :: dict,dict_minimal
@@ -927,8 +925,8 @@
     call f_routine(id='input_keys_fill_all')
 
     ! Overriding the default for isolated system
-    if ((POSINP .in. dict) .and. (DFT_VARIABLES .in. dict) ) then
-       if ( (ASTRUCT_CELL .notin. dict//POSINP) .and. (DISABLE_SYM .notin. dict//DFT_VARIABLES)) then
+    if (POSINP .in. dict) then
+       if (.not.has_key(dict//POSINP,ASTRUCT_CELL) .and. .not. has_key(dict//DFT_VARIABLES,DISABLE_SYM)) then
           call set(dict // DFT_VARIABLES // DISABLE_SYM,.true.)
        end if
     end if
@@ -936,8 +934,9 @@
 
     ! Check and complete dictionary.
     call input_keys_init()
-! call yaml_map('present status',dict)
-    call input_file_complete(parameters,dict,imports=profiles,nocheck=nested)
+
+
+    call input_file_complete(parameters,dict,nocheck=nested)
 
     !create a shortened dictionary which will be associated to the given run
     !call input_minimal(dict,dict_minimal)

=== modified file 'src/modules/module_sqn.f90'
--- src/modules/module_sqn.f90	2015-06-16 19:23:59 +0000
+++ src/modules/module_sqn.f90	2015-02-13 11:46:57 +0000
@@ -265,9 +265,9 @@
                   (pos(3,iat)-pos(3,jat))**2
             if (dist2.le.(1.2_gp*(rcov(iat)+rcov(jat)))**2) then
                 nbond=nbond+1
-                if (nbond.gt.1000) call f_err_throw(&
+                if (nbond.gt.1000) stop &
                      'nbond>1000, increase size of iconnect in '//&
-                     'routine which calls subroutine findbonds')
+                     'routine which calls subroutine findbonds'
                 iconnect(1,nbond)=iat
                 iconnect(2,nbond)=jat
             endif

=== modified file 'tests/tols-BigDFT.yaml'
--- tests/tols-BigDFT.yaml	2015-06-18 12:24:41 +0000
+++ tests/tols-BigDFT.yaml	2015-06-14 20:39:54 +0000
@@ -306,7 +306,7 @@
  EXC: 1.1e-10
  EvXC: 1.1e-10
  Enl: 2.1e-11
- Energy (Hartree): 1.43e-11
+ Energy (Hartree): 1.4e-11
 
 IO-wf_plain-read:
  Energies: 1.1e-10

